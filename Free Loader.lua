-- This file was protected by Trip Hub Obfuscator v5


return(function()local ke=string.char;local eB=string.gsub;local pM=string.sub;local oU=tonumber;local sQ=table.concat;local dOO=347;local H,KX=[=[l9,P,Q,I=select,1,nil,nil,nil;repeat if l9<=0x000 then Q=Jf;l9=2;else if l9==0X1 then P={[0]={[0X00000]=Af,0X1,2,Bf,4,ff,0X006,7,Of,0X09,10,0X000B,12,0X000d,14,0XF},{[0]=1,0,3,2,5,4,7,6,0X00009,0X8,0Xb,10,0X00d,12,15,Vf},{[0]=2,3,0X00,0X1,6,0X7,4,5,0XA,0x000b,8,nf,0XE,0xf,0Xc,0X00d},{[0]=0X3,2,1,0X0,bf,6,5,0x0004,0X00B,0Xa,9,0x8,0Xf,0X000e,0xd,0xc},{[0]=4,5,6,7,0,0X001,0X002,0X3,12,0x000d,0X0E,0X0F,0X8,9,10,0xB},{[0]=ff,4,7,6,1,0,0X0003,2,Df,12,0X0000F,14,0X00009,Of,0X0B,10},{[0]=6,7,4,0x5,2,3,0X000,0X001,14,0XF,0Xc,13,10,0X0b,8,nf},{[0X00]=0X7,6,5,jf,3,2,0X1,0,0Xf,14,0xd,0Xc,11,10,9,0x8},{[0]=8,9,0x0a,0xb,12,Df,14,Ef,0,1,0x2,3,0x4,5,0x006,7},{[0]=0X9,0x00008,0XB,10,0X0D,0XC,15,Vf,0X01,0x0000,0X003,vf,0X5,4,0X07,6},{[0X00000]=0xA,0xb,0X8,nf,14,15,0X00C,13,0x2,0X003,0X0,0x0001,6,0x7,0X4,0X5},{[0]=11,0Xa,9,8,0X0000f,0XE,13,0X00C,3,0X2,0x0001,0,0X00007,xf,ff,0X4},{[0X0]=0X0000c,0x0D,0Xe,0X0000F,8,0X00009,0Xa,11,jf,5,xf,0X7,0X0,0X001,0x2,0x3},{[0X0000]=Df,0X00c,0X000f,0Xe,nf,0X8,0XB,10,5,4,bf,6,1,0X0,3,vf},{[0]=14,15,12,13,Ff,0xB,0X08,9,0X006,7,4,0x0005,2,3,0,1},{[0]=0X0F,14,0Xd,0XC,0XB,0Xa,9,0X00008,0X7,6,0X5,0x4,Bf,2,0X0001,0}};l9=0X000;else I=mf;l9=0X3;end;end;until l9>=3]=],{0x1,0x2,0x3};local TA=(function(...)local b=(function(...)local c={}local d={}local e={}local f={}local g={}local h={}local i=8;local function j(k)if not k then error("assertion failed!")end end;function c:make_getS(l)local m=l;return function()if not m then return nil end;local n=m;m=nil;return n end end;function c:make_getF(o)local p=512;local q=1;return function()local l=o:sub(q,q+p-1)q=math.min(#o+1,q+p)return l end end;function c:init(r,n)if not r then return end;local s={}s.reader=r;s.data=n or""s.name=name;if not n or n==""then s.n=0 else s.n=#n end;s.p=0;return s end;function c:fill(s)local l=s.reader()s.data=l;if not l or l==""then return"EOZ"end;s.n,s.p=#l-1,1;return string.sub(l,1,1)end;function c:zgetc(s)local t,u=s.n,s.p+1;if t>0 then s.n,s.p=t-1,u;return string.sub(s.data,u,u)else return self:fill(s)end end;e.RESERVED="TK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>"e.MAXSRC=80;e.MAX_INT=2147483645;e.LUA_QS="'%s'"e.LUA_COMPAT_LSTR=1;function e:init()local v,w={},{}for y in string.gmatch(self.RESERVED,"[^\n]+")do local z,z,A,B=string.find(y,"(%S+)%s+(%S+)")v[A]=B;w[B]=A end;self.tokens=v;self.enums=w end;function e:chunkid(o,C)local D;local E=string.sub(o,1,1)if E=="="then D=string.sub(o,2,C)else if E=="@"then o=string.sub(o,2)C=C-#" '...' "local F=#o;D=""if F>C then o=string.sub(o,1+F-C)D=D.."..."end;D=D..o else local G=string.find(o,"[\n\r]")G=G and G-1 or#o;C=C-#" [string \"...\"] "if G>C then G=C end;D="[string \""if G<#o then D=D..string.sub(o,1,G).."..."else D=D..o end;D=D.."\"]"end end;return D end;function e:token2str(H,I)if string.sub(I,1,3)~="TK_"then if string.find(I,"%c")then return string.format("char(%d)",string.byte(I))end;return I else return self.tokens[I]end end;function e:lexerror(H,J,I)local function K(H,I)if I=="TK_NAME"or I=="TK_STRING"or I=="TK_NUMBER"then return H.buff else return self:token2str(H,I)end end;local l=self:chunkid(H.source,self.MAXSRC)local J=string.format("%s:%d: %s",l,H.linenumber,J)if I then J=string.format("%s near "..self.LUA_QS,J,K(H,I))end;error(J)end;function e:syntaxerror(H,J)self:lexerror(H,J,H.t.token)end;function e:currIsNewline(H)return H.current=="\n"or H.current=="\r"end;function e:inclinenumber(H)local L=H.current;self:nextc(H)if self:currIsNewline(H)and H.current~=L then self:nextc(H)end;H.linenumber=H.linenumber+1;if H.linenumber>=self.MAX_INT then self:syntaxerror(H,"chunk has too many lines")end end;function e:setinput(M,H,s,o)if not H then H={}end;if not H.lookahead then H.lookahead={}end;if not H.t then H.t={}end;H.decpoint="."H.L=M;H.lookahead.token="TK_EOS"H.z=s;H.fs=nil;H.linenumber=1;H.lastline=1;H.source=o;self:nextc(H)end;function e:check_next(H,N)if not string.find(N,H.current,1,1)then return false end;self:save_and_next(H)return true end;function e:next(H)H.lastline=H.linenumber;if H.lookahead.token~="TK_EOS"then H.t.seminfo=H.lookahead.seminfo;H.t.token=H.lookahead.token;H.lookahead.token="TK_EOS"else H.t.token=self:llex(H,H.t)end end;function e:lookahead(H)H.lookahead.token=self:llex(H,H.lookahead)end;function e:nextc(H)local O=c:zgetc(H.z)H.current=O;return O end;function e:save(H,O)local l=H.buff;H.buff=l..O end;function e:save_and_next(H)self:save(H,H.current)return self:nextc(H)end;function e:str2d(P)local Q=tonumber(P)if Q then return Q end;if string.lower(string.sub(P,1,2))=="0x"then Q=tonumber(P,16)if Q then return Q end end;return nil end;function e:buffreplace(H,R,S)local Q,l="",H.buff;for u=1,#l do local O=string.sub(l,u,u)if O==R then O=S end;Q=Q..O end;H.buff=Q end;function e:trydecpoint(H,T)local L=H.decpoint;self:buffreplace(H,L,H.decpoint)local U=self:str2d(H.buff)T.seminfo=U;if not U then self:buffreplace(H,H.decpoint,".")self:lexerror(H,"malformed number","TK_NUMBER")end end;function e:read_numeral(H,T)repeat self:save_and_next(H)until string.find(H.current,"%D")and H.current~="."if self:check_next(H,"Ee")then self:check_next(H,"+-")end;while string.find(H.current,"^%w$")or H.current=="_"do self:save_and_next(H)end;self:buffreplace(H,".",H.decpoint)local U=self:str2d(H.buff)T.seminfo=U;if not U then self:trydecpoint(H,T)end end;function e:skip_sep(H)local V=0;local P=H.current;self:save_and_next(H)while H.current=="="do self:save_and_next(H)V=V+1 end;return H.current==P and V or-V-1 end;function e:read_long_string(H,T,W)local X=0;self:save_and_next(H)if self:currIsNewline(H)then self:inclinenumber(H)end;while true do local O=H.current;if O=="EOZ"then self:lexerror(H,T and"unfinished long string"or"unfinished long comment","TK_EOS")elseif O=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(H)==W then self:save_and_next(H)X=X+1;if self.LUA_COMPAT_LSTR==1 then if W==0 then self:lexerror(H,"nesting of [[...]] is deprecated","[")end end end end elseif O=="]"then if self:skip_sep(H)==W then self:save_and_next(H)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then X=X-1;if W==0 and X>=0 then break end end;break end elseif self:currIsNewline(H)then self:save(H,"\n")self:inclinenumber(H)if not T then H.buff=""end else if T then self:save_and_next(H)else self:nextc(H)end end end;if T then local u=3+W;T.seminfo=string.sub(H.buff,u,-u)end end;function e:read_string(H,Y,T)self:save_and_next(H)while H.current~=Y do local O=H.current;if O=="EOZ"then self:lexerror(H,"unfinished string","TK_EOS")elseif self:currIsNewline(H)then self:lexerror(H,"unfinished string","TK_STRING")elseif O=="\\"then O=self:nextc(H)if self:currIsNewline(H)then self:save(H,"\n")self:inclinenumber(H)elseif O~="EOZ"then local Z=string.find("abfnrtv",O,1,1)if Z then self:save(H,string.sub("\a\b\f\n\r\t\v",Z,Z))self:nextc(H)elseif not string.find(O,"%d")then self:save_and_next(H)else O,Z=0,0;repeat O=10*O+H.current;self:nextc(H)Z=Z+1 until Z>=3 or not string.find(H.current,"%d")if O>255 then self:lexerror(H,"escape sequence too large","TK_STRING")end;self:save(H,string.char(O))end end else self:save_and_next(H)end end;self:save_and_next(H)T.seminfo=string.sub(H.buff,2,-2)end;function e:llex(H,T)H.buff=""while true do local O=H.current;if self:currIsNewline(H)then self:inclinenumber(H)elseif O=="-"then O=self:nextc(H)if O~="-"then return"-"end;local W=-1;if self:nextc(H)=='['then W=self:skip_sep(H)H.buff=""end;if W>=0 then self:read_long_string(H,nil,W)H.buff=""else while not self:currIsNewline(H)and H.current~="EOZ"do self:nextc(H)end end elseif O=="["then local W=self:skip_sep(H)if W>=0 then self:read_long_string(H,T,W)return"TK_STRING"elseif W==-1 then return"["else self:lexerror(H,"invalid long string delimiter","TK_STRING")end elseif O=="="then O=self:nextc(H)if O~="="then return"="else self:nextc(H)return"TK_EQ"end elseif O=="<"then O=self:nextc(H)if O~="="then return"<"else self:nextc(H)return"TK_LE"end elseif O==">"then O=self:nextc(H)if O~="="then return">"else self:nextc(H)return"TK_GE"end elseif O=="~"then O=self:nextc(H)if O~="="then return"~"else self:nextc(H)return"TK_NE"end elseif O=="\""or O=="'"then self:read_string(H,O,T)return"TK_STRING"elseif O=="."then O=self:save_and_next(H)if self:check_next(H,".")then if self:check_next(H,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(O,"%d")then return"."else self:read_numeral(H,T)return"TK_NUMBER"end elseif O=="EOZ"then return"TK_EOS"else if string.find(O,"%s")then self:nextc(H)elseif string.find(O,"%d")then self:read_numeral(H,T)return"TK_NUMBER"elseif string.find(O,"[_%a]")then repeat O=self:save_and_next(H)until O=="EOZ"or not string.find(O,"[_%w]")local _=H.buff;local A=self.enums[_]if A then return A end;T.seminfo=_;return"TK_NAME"else self:nextc(H)return O end end end end;f.OpMode={iABC=0,iABx=1,iAsBx=2}f.SIZE_C=9;f.SIZE_B=9;f.SIZE_Bx=f.SIZE_C+f.SIZE_B;f.SIZE_A=8;f.SIZE_OP=6;f.POS_OP=0;f.POS_A=f.POS_OP+f.SIZE_OP;f.POS_C=f.POS_A+f.SIZE_A;f.POS_B=f.POS_C+f.SIZE_C;f.POS_Bx=f.POS_C;f.MAXARG_Bx=math.ldexp(1,f.SIZE_Bx)-1;f.MAXARG_sBx=math.floor(f.MAXARG_Bx/2)f.MAXARG_A=math.ldexp(1,f.SIZE_A)-1;f.MAXARG_B=math.ldexp(1,f.SIZE_B)-1;f.MAXARG_C=math.ldexp(1,f.SIZE_C)-1;function f:GET_OPCODE(Z)return self.ROpCode[Z.OP]end;function f:SET_OPCODE(Z,a0)Z.OP=self.OpCode[a0]end;function f:GETARG_A(Z)return Z.A end;function f:SETARG_A(Z,a1)Z.A=a1 end;function f:GETARG_B(Z)return Z.B end;function f:SETARG_B(Z,m)Z.B=m end;function f:GETARG_C(Z)return Z.C end;function f:SETARG_C(Z,m)Z.C=m end;function f:GETARG_Bx(Z)return Z.Bx end;function f:SETARG_Bx(Z,m)Z.Bx=m end;function f:GETARG_sBx(Z)return Z.Bx-self.MAXARG_sBx end;function f:SETARG_sBx(Z,m)Z.Bx=m+self.MAXARG_sBx end;function f:CREATE_ABC(a0,a2,m,O)return{OP=self.OpCode[a0],A=a2,B=m,C=O}end;function f:CREATE_ABx(a0,a2,a3)return{OP=self.OpCode[a0],A=a2,Bx=a3}end;function f:CREATE_Inst(O)local a0=O%64;O=(O-a0)/64;local a2=O%256;O=(O-a2)/256;return self:CREATE_ABx(a0,a2,O)end;function f:Instruction(Z)if Z.Bx then Z.C=Z.Bx%512;Z.B=(Z.Bx-Z.C)/512 end;local a4=Z.A*64+Z.OP;local a5=a4%256;a4=Z.C*64+(a4-a5)/256;local a6=a4%256;a4=Z.B*128+(a4-a6)/256;local a7=a4%256;local a8=(a4-a7)/256;return string.char(a5,a6,a7,a8)end;function f:DecodeInst(x)local a9=string.byte;local Z={}local a4=a9(x,1)local aa=a4%64;Z.OP=aa;a4=a9(x,2)*4+(a4-aa)/64;local a2=a4%256;Z.A=a2;a4=a9(x,3)*4+(a4-a2)/256;local O=a4%512;Z.C=O;Z.B=a9(x,4)*2+(a4-O)/512;local ab=self.OpMode[tonumber(string.sub(self.opmodes[aa+1],7,7))]if ab~="iABC"then Z.Bx=Z.B*512+Z.C end;return Z end;f.BITRK=math.ldexp(1,f.SIZE_B-1)function f:ISK(x)return x>=self.BITRK end;function f:INDEXK(ac)return x-self.BITRK end;f.MAXINDEXRK=f.BITRK-1;function f:RKASK(x)return x+self.BITRK end;f.NO_REG=f.MAXARG_A;f.opnames={}f.OpCode={}f.ROpCode={}local Z=0;for y in string.gmatch("MOVE LOADK LOADBOOL LOADNIL GETUPVAL\nGETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE\nNEWTABLE SELF ADD SUB MUL\nDIV MOD POW UNM NOT\nLEN CONCAT JMP EQ LT\nLE TEST TESTSET CALL TAILCALL\nRETURN FORLOOP FORPREP TFORLOOP SETLIST\nCLOSE CLOSURE VARARG","%S+")do local t="OP_"..y;f.opnames[Z]=y;f.OpCode[t]=Z;f.ROpCode[Z]=t;Z=Z+1 end;f.NUM_OPCODES=Z;f.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function f:getOpMode(ad)return self.opmodes[self.OpCode[ad]]%4 end;function f:getBMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/16)%4 end;function f:getCMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/4)%4 end;function f:testAMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/64)%2 end;function f:testTMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/128)end;f.LFIELDS_PER_FLUSH=50;local function ab(ae,a2,m,O,ad)local f=f;return ae*128+a2*64+f.OpArgMask[m]*16+f.OpArgMask[O]*4+f.OpMode[ad]end;f.opmodes={ab(0,1,"OpArgK","OpArgN","iABx"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgU","OpArgN","iABC"),ab(0,1,"OpArgK","OpArgN","iABx"),ab(0,1,"OpArgR","OpArgK","iABC"),ab(0,0,"OpArgK","OpArgN","iABx"),ab(0,0,"OpArgU","OpArgN","iABC"),ab(0,0,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgR","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgR","iABC"),ab(0,0,"OpArgR","OpArgN","iAsBx"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,1,"OpArgR","OpArgU","iABC"),ab(1,1,"OpArgR","OpArgU","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,0,"OpArgU","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iAsBx"),ab(0,1,"OpArgR","OpArgN","iAsBx"),ab(1,0,"OpArgN","OpArgU","iABC"),ab(0,0,"OpArgU","OpArgU","iABC"),ab(0,0,"OpArgN","OpArgN","iABC"),ab(0,1,"OpArgU","OpArgN","iABx"),ab(0,1,"OpArgU","OpArgN","iABC")}f.opmodes[0]=ab(0,1,"OpArgR","OpArgN","iABC")g.LUA_SIGNATURE="\27Lua"g.LUA_TNUMBER=3;g.LUA_TSTRING=4;g.LUA_TNIL=0;g.LUA_TBOOLEAN=1;g.LUA_TNONE=-1;g.LUAC_VERSION=0x51;g.LUAC_FORMAT=0;g.LUAC_HEADERSIZE=12;function g:make_setS()local l={}l.data=""local af=function(P,l)if not P then return 0 end;l.data=l.data..P;return 0 end;return af,l end;function g:make_setF(ag)local l={}l.h=io.open(ag,"wb")if not l.h then return nil end;local af=function(P,l)if not l.h then return 0 end;if not P then if l.h:close()then return 0 end else if l.h:write(P)then return 0 end end;return 1 end;return af,l end;function g:ttype(a0)local ah=type(a0.value)if ah=="number"then return self.LUA_TNUMBER elseif ah=="string"then return self.LUA_TSTRING elseif ah=="nil"then return self.LUA_TNIL elseif ah=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function g:from_double(x)local function ai(y)local O=y%256;return(y-O)/256,string.char(O)end;local aj=0;if x<0 then aj=1;x=-x end;local ak,al=math.frexp(x)if x==0 then ak,al=0,0 elseif x==1/0 then ak,al=0,2047 else ak=(ak*2-1)*math.ldexp(0.5,53)al=al+1022 end;local y,a9=""x=math.floor(ak)for Z=1,6 do x,a9=ai(x)y=y..a9 end;x,a9=ai(al*16+x)y=y..a9;x,a9=ai(aj*128+x)y=y..a9;return y end;function g:from_int(x)local y=""x=math.floor(x)if x<0 then x=4294967296+x end;for Z=1,4 do local O=x%256;y=y..string.char(O)x=math.floor(x/256)end;return y end;function g:DumpBlock(m,am)if am.status==0 then am.status=am.write(m,am.data)end end;function g:DumpChar(an,am)self:DumpBlock(string.char(an),am)end;function g:DumpInt(x,am)self:DumpBlock(self:from_int(x),am)end;function g:DumpSizeT(x,am)self:DumpBlock(self:from_int(x),am)if i==8 then self:DumpBlock(self:from_int(0),am)end end;function g:DumpNumber(x,am)self:DumpBlock(self:from_double(x),am)end;function g:DumpString(P,am)if P==nil then self:DumpSizeT(0,am)else P=P.."\0"self:DumpSizeT(#P,am)self:DumpBlock(P,am)end end;function g:DumpCode(ao,am)local t=ao.sizecode;self:DumpInt(t,am)for Z=0,t-1 do self:DumpBlock(f:Instruction(ao.code[Z]),am)end end;function g:DumpConstants(ao,am)local t=ao.sizek;self:DumpInt(t,am)for Z=0,t-1 do local a0=ao.k[Z]local ah=self:ttype(a0)self:DumpChar(ah,am)if ah==self.LUA_TNIL then elseif ah==self.LUA_TBOOLEAN then self:DumpChar(a0.value and 1 or 0,am)elseif ah==self.LUA_TNUMBER then self:DumpNumber(a0.value,am)elseif ah==self.LUA_TSTRING then self:DumpString(a0.value,am)else end end;t=ao.sizep;self:DumpInt(t,am)for Z=0,t-1 do self:DumpFunction(ao.p[Z],ao.source,am)end end;function g:DumpDebug(ao,am)local t;t=am.strip and 0 or ao.sizelineinfo;self:DumpInt(t,am)for Z=0,t-1 do self:DumpInt(ao.lineinfo[Z],am)end;t=am.strip and 0 or ao.sizelocvars;self:DumpInt(t,am)for Z=0,t-1 do self:DumpString(ao.locvars[Z].varname,am)self:DumpInt(ao.locvars[Z].startpc,am)self:DumpInt(ao.locvars[Z].endpc,am)end;t=am.strip and 0 or ao.sizeupvalues;self:DumpInt(t,am)for Z=0,t-1 do self:DumpString(ao.upvalues[Z],am)end end;function g:DumpFunction(ao,u,am)local o=ao.source;if o==u or am.strip then o=nil end;self:DumpString(o,am)self:DumpInt(ao.lineDefined,am)self:DumpInt(ao.lastlinedefined,am)self:DumpChar(ao.nups,am)self:DumpChar(ao.numparams,am)self:DumpChar(ao.is_vararg,am)self:DumpChar(ao.maxstacksize,am)self:DumpCode(ao,am)self:DumpConstants(ao,am)self:DumpDebug(ao,am)end;function g:DumpHeader(am)local ap=self:header()assert(#ap==self.LUAC_HEADERSIZE)self:DumpBlock(ap,am)end;function g:header()local x=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,i,4,8,0)end;function g:dump(M,ao,aq,n,ar)local am={}am.L=M;am.write=aq;am.data=n;am.strip=ar;am.status=0;self:DumpHeader(am)self:DumpFunction(ao,nil,am)am.write(nil,am.data)return am.status end;h.MAXSTACK=250;function h:ttisnumber(a0)if a0 then return type(a0.value)=="number"else return false end end;function h:nvalue(a0)return a0.value end;function h:setnilvalue(a0)a0.value=nil end;function h:setsvalue(a0,x)a0.value=x end;h.setnvalue=h.setsvalue;h.sethvalue=h.setsvalue;h.setbvalue=h.setsvalue;function h:numadd(a2,m)return a2+m end;function h:numsub(a2,m)return a2-m end;function h:nummul(a2,m)return a2*m end;function h:numdiv(a2,m)return a2/m end;function h:nummod(a2,m)return a2%m end;function h:numpow(a2,m)return a2^m end;function h:numunm(a2)return-a2 end;function h:numisnan(a2)return not a2==a2 end;h.NO_JUMP=-1;h.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}h.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function h:getcode(as,at)return as.f.code[at.info]end;function h:codeAsBx(as,a0,au,av)return self:codeABx(as,a0,au,av+f.MAXARG_sBx)end;function h:setmultret(as,at)self:setreturns(as,at,d.LUA_MULTRET)end;function h:hasjumps(at)return at.t~=at.f end;function h:isnumeral(at)return at.k=="VKNUM"and at.t==self.NO_JUMP and at.f==self.NO_JUMP end;function h:_nil(as,R,t)if as.pc>as.lasttarget then if as.pc==0 then if R>=as.nactvar then return end else local aw=as.f.code[as.pc-1]if f:GET_OPCODE(aw)=="OP_LOADNIL"then local ax=f:GETARG_A(aw)local ay=f:GETARG_B(aw)if ax<=R and R<=ay+1 then if R+t-1>ay then f:SETARG_B(aw,R+t-1)end;return end end end end;self:codeABC(as,"OP_LOADNIL",R,R+t-1,0)end;function h:jump(as)local az=as.jpc;as.jpc=self.NO_JUMP;local aA=self:codeAsBx(as,"OP_JMP",0,self.NO_JUMP)aA=self:concat(as,aA,az)return aA end;function h:ret(as,E,aB)self:codeABC(as,"OP_RETURN",E,aB+1,0)end;function h:condjump(as,aa,au,aC,aD)self:codeABC(as,aa,au,aC,aD)return self:jump(as)end;function h:fixjump(as,aE,aF)local aG=as.f.code[aE]local aH=aF-(aE+1)j(aF~=self.NO_JUMP)if math.abs(aH)>f.MAXARG_sBx then e:syntaxerror(as.ls,"control structure too long")end;f:SETARG_sBx(aG,aH)end;function h:getlabel(as)as.lasttarget=as.pc;return as.pc end;function h:getjump(as,aE)local aH=f:GETARG_sBx(as.f.code[aE])if aH==self.NO_JUMP then return self.NO_JUMP else return aE+1+aH end end;function h:getjumpcontrol(as,aE)local aI=as.f.code[aE]local aJ=as.f.code[aE-1]if aE>=1 and f:testTMode(f:GET_OPCODE(aJ))~=0 then return aJ else return aI end end;function h:need_value(as,aK)while aK~=self.NO_JUMP do local Z=self:getjumpcontrol(as,aK)if f:GET_OPCODE(Z)~="OP_TESTSET"then return true end;aK=self:getjump(as,aK)end;return false end;function h:patchtestreg(as,aL,aM)local Z=self:getjumpcontrol(as,aL)if f:GET_OPCODE(Z)~="OP_TESTSET"then return false end;if aM~=f.NO_REG and aM~=f:GETARG_B(Z)then f:SETARG_A(Z,aM)else f:SET_OPCODE(Z,"OP_TEST")local m=f:GETARG_B(Z)f:SETARG_A(Z,m)f:SETARG_B(Z,0)end;return true end;function h:removevalues(as,aK)while aK~=self.NO_JUMP do self:patchtestreg(as,aK,f.NO_REG)aK=self:getjump(as,aK)end end;function h:patchlistaux(as,aK,aN,aM,aO)while aK~=self.NO_JUMP do local aP=self:getjump(as,aK)if self:patchtestreg(as,aK,aM)then self:fixjump(as,aK,aN)else self:fixjump(as,aK,aO)end;aK=aP end end;function h:dischargejpc(as)self:patchlistaux(as,as.jpc,as.pc,f.NO_REG,as.pc)as.jpc=self.NO_JUMP end;function h:patchlist(as,aK,aQ)if aQ==as.pc then self:patchtohere(as,aK)else j(aQ<as.pc)self:patchlistaux(as,aK,aQ,f.NO_REG,aQ)end end;function h:patchtohere(as,aK)self:getlabel(as)as.jpc=self:concat(as,as.jpc,aK)end;function h:concat(as,aR,aS)if aS==self.NO_JUMP then return aR elseif aR==self.NO_JUMP then return aS else local aK=aR;local aP=self:getjump(as,aK)while aP~=self.NO_JUMP do aK=aP;aP=self:getjump(as,aK)end;self:fixjump(as,aK,aS)end;return aR end;function h:checkstack(as,t)local aT=as.freereg+t;if aT>as.f.maxstacksize then if aT>=self.MAXSTACK then e:syntaxerror(as.ls,"function or expression too complex")end;as.f.maxstacksize=aT end end;function h:reserveregs(as,t)self:checkstack(as,t)as.freereg=as.freereg+t end;function h:freereg(as,aM)if not f:ISK(aM)and aM>=as.nactvar then as.freereg=as.freereg-1;j(aM==as.freereg)end end;function h:freeexp(as,at)if at.k=="VNONRELOC"then self:freereg(as,at.info)end end;function h:addk(as,aU,y)local M=as.L;local aV=as.h[aU.value]local ao=as.f;if self:ttisnumber(aV)then return self:nvalue(aV)else aV={}self:setnvalue(aV,as.nk)as.h[aU.value]=aV;d:growvector(M,ao.k,as.nk,ao.sizek,nil,f.MAXARG_Bx,"constant table overflow")ao.k[as.nk]=y;local aW=as.nk;as.nk=as.nk+1;return aW end end;function h:stringK(as,P)local a0={}self:setsvalue(a0,P)return self:addk(as,a0,a0)end;function h:numberK(as,ac)local a0={}self:setnvalue(a0,ac)return self:addk(as,a0,a0)end;function h:boolK(as,m)local a0={}self:setbvalue(a0,m)return self:addk(as,a0,a0)end;function h:nilK(as)local aU,y={},{}self:setnilvalue(y)self:sethvalue(aU,as.h)return self:addk(as,aU,y)end;function h:setreturns(as,at,aX)if at.k=="VCALL"then f:SETARG_C(self:getcode(as,at),aX+1)elseif at.k=="VVARARG"then f:SETARG_B(self:getcode(as,at),aX+1)f:SETARG_A(self:getcode(as,at),as.freereg)h:reserveregs(as,1)end end;function h:setoneret(as,at)if at.k=="VCALL"then at.k="VNONRELOC"at.info=f:GETARG_A(self:getcode(as,at))elseif at.k=="VVARARG"then f:SETARG_B(self:getcode(as,at),2)at.k="VRELOCABLE"end end;function h:dischargevars(as,at)local aU=at.k;if aU=="VLOCAL"then at.k="VNONRELOC"elseif aU=="VUPVAL"then at.info=self:codeABC(as,"OP_GETUPVAL",0,at.info,0)at.k="VRELOCABLE"elseif aU=="VGLOBAL"then at.info=self:codeABx(as,"OP_GETGLOBAL",0,at.info)at.k="VRELOCABLE"elseif aU=="VINDEXED"then self:freereg(as,at.aux)self:freereg(as,at.info)at.info=self:codeABC(as,"OP_GETTABLE",0,at.info,at.aux)at.k="VRELOCABLE"elseif aU=="VVARARG"or aU=="VCALL"then self:setoneret(as,at)else end end;function h:code_label(as,au,m,aY)self:getlabel(as)return self:codeABC(as,"OP_LOADBOOL",au,m,aY)end;function h:discharge2reg(as,at,aM)self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"then self:_nil(as,aM,1)elseif aU=="VFALSE"or aU=="VTRUE"then self:codeABC(as,"OP_LOADBOOL",aM,at.k=="VTRUE"and 1 or 0,0)elseif aU=="VK"then self:codeABx(as,"OP_LOADK",aM,at.info)elseif aU=="VKNUM"then self:codeABx(as,"OP_LOADK",aM,self:numberK(as,at.nval))elseif aU=="VRELOCABLE"then local aE=self:getcode(as,at)f:SETARG_A(aE,aM)elseif aU=="VNONRELOC"then if aM~=at.info then self:codeABC(as,"OP_MOVE",aM,at.info,0)end else j(at.k=="VVOID"or at.k=="VJMP")return end;at.info=aM;at.k="VNONRELOC"end;function h:discharge2anyreg(as,at)if at.k~="VNONRELOC"then self:reserveregs(as,1)self:discharge2reg(as,at,as.freereg-1)end end;function h:exp2reg(as,at,aM)self:discharge2reg(as,at,aM)if at.k=="VJMP"then at.t=self:concat(as,at.t,at.info)end;if self:hasjumps(at)then local aZ;local a_=self.NO_JUMP;local b0=self.NO_JUMP;if self:need_value(as,at.t)or self:need_value(as,at.f)then local b1=at.k=="VJMP"and self.NO_JUMP or self:jump(as)a_=self:code_label(as,aM,0,1)b0=self:code_label(as,aM,1,0)self:patchtohere(as,b1)end;aZ=self:getlabel(as)self:patchlistaux(as,at.f,aZ,aM,a_)self:patchlistaux(as,at.t,aZ,aM,b0)end;at.f,at.t=self.NO_JUMP,self.NO_JUMP;at.info=aM;at.k="VNONRELOC"end;function h:exp2nextreg(as,at)self:dischargevars(as,at)self:freeexp(as,at)self:reserveregs(as,1)self:exp2reg(as,at,as.freereg-1)end;function h:exp2anyreg(as,at)self:dischargevars(as,at)if at.k=="VNONRELOC"then if not self:hasjumps(at)then return at.info end;if at.info>=as.nactvar then self:exp2reg(as,at,at.info)return at.info end end;self:exp2nextreg(as,at)return at.info end;function h:exp2val(as,at)if self:hasjumps(at)then self:exp2anyreg(as,at)else self:dischargevars(as,at)end end;function h:exp2RK(as,at)self:exp2val(as,at)local aU=at.k;if aU=="VKNUM"or aU=="VTRUE"or aU=="VFALSE"or aU=="VNIL"then if as.nk<=f.MAXINDEXRK then if at.k=="VNIL"then at.info=self:nilK(as)else at.info=at.k=="VKNUM"and self:numberK(as,at.nval)or self:boolK(as,at.k=="VTRUE")end;at.k="VK"return f:RKASK(at.info)end elseif aU=="VK"then if at.info<=f.MAXINDEXRK then return f:RKASK(at.info)end else end;return self:exp2anyreg(as,at)end;function h:storevar(as,b2,b3)local aU=b2.k;if aU=="VLOCAL"then self:freeexp(as,b3)self:exp2reg(as,b3,b2.info)return elseif aU=="VUPVAL"then local at=self:exp2anyreg(as,b3)self:codeABC(as,"OP_SETUPVAL",at,b2.info,0)elseif aU=="VGLOBAL"then local at=self:exp2anyreg(as,b3)self:codeABx(as,"OP_SETGLOBAL",at,b2.info)elseif aU=="VINDEXED"then local at=self:exp2RK(as,b3)self:codeABC(as,"OP_SETTABLE",b2.info,b2.aux,at)else j(0)end;self:freeexp(as,b3)end;function h:_self(as,at,b4)self:exp2anyreg(as,at)self:freeexp(as,at)local b5=as.freereg;self:reserveregs(as,2)self:codeABC(as,"OP_SELF",b5,at.info,self:exp2RK(as,b4))self:freeexp(as,b4)at.info=b5;at.k="VNONRELOC"end;function h:invertjump(as,at)local aE=self:getjumpcontrol(as,at.info)j(f:testTMode(f:GET_OPCODE(aE))~=0 and f:GET_OPCODE(aE)~="OP_TESTSET"and f:GET_OPCODE(aE)~="OP_TEST")f:SETARG_A(aE,f:GETARG_A(aE)==0 and 1 or 0)end;function h:jumponcond(as,at,b6)if at.k=="VRELOCABLE"then local b7=self:getcode(as,at)if f:GET_OPCODE(b7)=="OP_NOT"then as.pc=as.pc-1;return self:condjump(as,"OP_TEST",f:GETARG_B(b7),0,b6 and 0 or 1)end end;self:discharge2anyreg(as,at)self:freeexp(as,at)return self:condjump(as,"OP_TESTSET",f.NO_REG,at.info,b6 and 1 or 0)end;function h:goiftrue(as,at)local aE;self:dischargevars(as,at)local aU=at.k;if aU=="VK"or aU=="VKNUM"or aU=="VTRUE"then aE=self.NO_JUMP elseif aU=="VFALSE"then aE=self:jump(as)elseif aU=="VJMP"then self:invertjump(as,at)aE=at.info else aE=self:jumponcond(as,at,false)end;at.f=self:concat(as,at.f,aE)self:patchtohere(as,at.t)at.t=self.NO_JUMP end;function h:goiffalse(as,at)local aE;self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"or aU=="VFALSE"then aE=self.NO_JUMP elseif aU=="VTRUE"then aE=self:jump(as)elseif aU=="VJMP"then aE=at.info else aE=self:jumponcond(as,at,true)end;at.t=self:concat(as,at.t,aE)self:patchtohere(as,at.f)at.f=self.NO_JUMP end;function h:codenot(as,at)self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"or aU=="VFALSE"then at.k="VTRUE"elseif aU=="VK"or aU=="VKNUM"or aU=="VTRUE"then at.k="VFALSE"elseif aU=="VJMP"then self:invertjump(as,at)elseif aU=="VRELOCABLE"or aU=="VNONRELOC"then self:discharge2anyreg(as,at)self:freeexp(as,at)at.info=self:codeABC(as,"OP_NOT",0,at.info,0)at.k="VRELOCABLE"else j(0)end;at.f,at.t=at.t,at.f;self:removevalues(as,at.f)self:removevalues(as,at.t)end;function h:indexed(as,ae,aU)ae.aux=self:exp2RK(as,aU)ae.k="VINDEXED"end;function h:constfolding(aa,b8,b9)local ac;if not self:isnumeral(b8)or not self:isnumeral(b9)then return false end;local ba=b8.nval;local bb=b9.nval;if aa=="OP_ADD"then ac=self:numadd(ba,bb)elseif aa=="OP_SUB"then ac=self:numsub(ba,bb)elseif aa=="OP_MUL"then ac=self:nummul(ba,bb)elseif aa=="OP_DIV"then if bb==0 then return false end;ac=self:numdiv(ba,bb)elseif aa=="OP_MOD"then if bb==0 then return false end;ac=self:nummod(ba,bb)elseif aa=="OP_POW"then ac=self:numpow(ba,bb)elseif aa=="OP_UNM"then ac=self:numunm(ba)elseif aa=="OP_LEN"then return false else j(0)ac=0 end;if self:numisnan(ac)then return false end;b8.nval=ac;return true end;function h:codearith(as,aa,b8,b9)if self:constfolding(aa,b8,b9)then return else local bc=aa~="OP_UNM"and aa~="OP_LEN"and self:exp2RK(as,b9)or 0;local bd=self:exp2RK(as,b8)if bd>bc then self:freeexp(as,b8)self:freeexp(as,b9)else self:freeexp(as,b9)self:freeexp(as,b8)end;b8.info=self:codeABC(as,aa,0,bd,bc)b8.k="VRELOCABLE"end end;function h:codecomp(as,aa,b6,b8,b9)local bd=self:exp2RK(as,b8)local bc=self:exp2RK(as,b9)self:freeexp(as,b9)self:freeexp(as,b8)if b6==0 and aa~="OP_EQ"then bd,bc=bc,bd;b6=1 end;b8.info=self:condjump(as,aa,b6,bd,bc)b8.k="VJMP"end;function h:prefix(as,aa,at)local b9={}b9.t,b9.f=self.NO_JUMP,self.NO_JUMP;b9.k="VKNUM"b9.nval=0;if aa=="OPR_MINUS"then if not self:isnumeral(at)then self:exp2anyreg(as,at)end;self:codearith(as,"OP_UNM",at,b9)elseif aa=="OPR_NOT"then self:codenot(as,at)elseif aa=="OPR_LEN"then self:exp2anyreg(as,at)self:codearith(as,"OP_LEN",at,b9)else j(0)end end;function h:infix(as,aa,y)if aa=="OPR_AND"then self:goiftrue(as,y)elseif aa=="OPR_OR"then self:goiffalse(as,y)elseif aa=="OPR_CONCAT"then self:exp2nextreg(as,y)elseif aa=="OPR_ADD"or aa=="OPR_SUB"or aa=="OPR_MUL"or aa=="OPR_DIV"or aa=="OPR_MOD"or aa=="OPR_POW"then if not self:isnumeral(y)then self:exp2RK(as,y)end else self:exp2RK(as,y)end end;h.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}h.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}h.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function h:posfix(as,aa,b8,b9)local function be(b8,b9)b8.k=b9.k;b8.info=b9.info;b8.aux=b9.aux;b8.nval=b9.nval;b8.t=b9.t;b8.f=b9.f end;if aa=="OPR_AND"then j(b8.t==self.NO_JUMP)self:dischargevars(as,b9)b9.f=self:concat(as,b9.f,b8.f)be(b8,b9)elseif aa=="OPR_OR"then j(b8.f==self.NO_JUMP)self:dischargevars(as,b9)b9.t=self:concat(as,b9.t,b8.t)be(b8,b9)elseif aa=="OPR_CONCAT"then self:exp2val(as,b9)if b9.k=="VRELOCABLE"and f:GET_OPCODE(self:getcode(as,b9))=="OP_CONCAT"then j(b8.info==f:GETARG_B(self:getcode(as,b9))-1)self:freeexp(as,b8)f:SETARG_B(self:getcode(as,b9),b8.info)b8.k="VRELOCABLE"b8.info=b9.info else self:exp2nextreg(as,b9)self:codearith(as,"OP_CONCAT",b8,b9)end else local bf=self.arith_op[aa]if bf then self:codearith(as,bf,b8,b9)else local bg=self.comp_op[aa]if bg then self:codecomp(as,bg,self.comp_cond[aa],b8,b9)else j(0)end end end end;function h:fixline(as,bh)as.f.lineinfo[as.pc-1]=bh end;function h:code(as,Z,bh)local ao=as.f;self:dischargejpc(as)d:growvector(as.L,ao.code,as.pc,ao.sizecode,nil,d.MAX_INT,"code size overflow")ao.code[as.pc]=Z;d:growvector(as.L,ao.lineinfo,as.pc,ao.sizelineinfo,nil,d.MAX_INT,"code size overflow")ao.lineinfo[as.pc]=bh;local aE=as.pc;as.pc=as.pc+1;return aE end;function h:codeABC(as,a0,a2,m,O)j(f:getOpMode(a0)==f.OpMode.iABC)j(f:getBMode(a0)~=f.OpArgMask.OpArgN or m==0)j(f:getCMode(a0)~=f.OpArgMask.OpArgN or O==0)return self:code(as,f:CREATE_ABC(a0,a2,m,O),as.ls.lastline)end;function h:codeABx(as,a0,a2,a3)j(f:getOpMode(a0)==f.OpMode.iABx or f:getOpMode(a0)==f.OpMode.iAsBx)j(f:getCMode(a0)==f.OpArgMask.OpArgN)return self:code(as,f:CREATE_ABx(a0,a2,a3),as.ls.lastline)end;function h:setlist(as,bi,bj,bk)local O=math.floor((bj-1)/f.LFIELDS_PER_FLUSH)+1;local m=bk==d.LUA_MULTRET and 0 or bk;j(bk~=0)if O<=f.MAXARG_C then self:codeABC(as,"OP_SETLIST",bi,m,O)else self:codeABC(as,"OP_SETLIST",bi,m,0)self:code(as,f:CREATE_Inst(O),as.ls.lastline)end;as.freereg=bi+1 end;d.LUA_QS=e.LUA_QS or"'%s'"d.SHRT_MAX=32767;d.LUAI_MAXVARS=200;d.LUAI_MAXUPVALUES=60;d.MAX_INT=e.MAX_INT or 2147483645;d.LUAI_MAXCCALLS=200;d.VARARG_HASARG=1;d.HASARG_MASK=2;d.VARARG_ISVARARG=2;d.VARARG_NEEDSARG=4;d.LUA_MULTRET=-1;function d:LUA_QL(x)return"'"..x.."'"end;function d:growvector(M,y,bj,bl,ae,bm,at)if bj>=bm then error(at)end end;function d:newproto(M)local ao={}ao.k={}ao.sizek=0;ao.p={}ao.sizep=0;ao.code={}ao.sizecode=0;ao.sizelineinfo=0;ao.sizeupvalues=0;ao.nups=0;ao.upvalues={}ao.numparams=0;ao.is_vararg=0;ao.maxstacksize=0;ao.lineinfo={}ao.sizelocvars=0;ao.locvars={}ao.lineDefined=0;ao.lastlinedefined=0;ao.source=nil;return ao end;function d:int2fb(x)local at=0;while x>=16 do x=math.floor((x+1)/2)at=at+1 end;if x<8 then return x else return(at+1)*8+x-8 end end;function d:hasmultret(aU)return aU=="VCALL"or aU=="VVARARG"end;function d:getlocvar(as,Z)return as.f.locvars[as.actvar[Z]]end;function d:checklimit(as,y,F,ad)if y>F then self:errorlimit(as,F,ad)end end;function d:anchor_token(H)if H.t.token=="TK_NAME"or H.t.token=="TK_STRING"then end end;function d:error_expected(H,I)e:syntaxerror(H,string.format(self.LUA_QS.." expected",e:token2str(H,I)))end;function d:errorlimit(as,bm,bn)local J=as.f.linedefined==0 and string.format("main function has more than %d %s",bm,bn)or string.format("function at line %d has more than %d %s",as.f.linedefined,bm,bn)e:lexerror(as.ls,J,0)end;function d:testnext(H,O)if H.t.token==O then e:next(H)return true else return false end end;function d:check(H,O)if H.t.token~=O then self:error_expected(H,O)end end;function d:checknext(H,O)self:check(H,O)e:next(H)end;function d:check_condition(H,O,J)if not O then e:syntaxerror(H,J)end end;function d:check_match(H,bn,bo,bp)if not self:testnext(H,bn)then if bp==H.linenumber then self:error_expected(H,bn)else e:syntaxerror(H,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",e:token2str(H,bn),e:token2str(H,bo),bp))end end end;function d:str_checkname(H)self:check(H,"TK_NAME")local _=H.t.seminfo;e:next(H)return _ end;function d:init_exp(at,aU,Z)at.f,at.t=h.NO_JUMP,h.NO_JUMP;at.k=aU;at.info=Z end;function d:codestring(H,at,P)self:init_exp(at,"VK",h:stringK(H.fs,P))end;function d:checkname(H,at)self:codestring(H,at,self:str_checkname(H))end;function d:registerlocalvar(H,bq)local as=H.fs;local ao=as.f;self:growvector(H.L,ao.locvars,as.nlocvars,ao.sizelocvars,nil,self.SHRT_MAX,"too many local variables")ao.locvars[as.nlocvars]={}ao.locvars[as.nlocvars].varname=bq;local br=as.nlocvars;as.nlocvars=as.nlocvars+1;return br end;function d:new_localvarliteral(H,y,t)self:new_localvar(H,y,t)end;function d:new_localvar(H,name,t)local as=H.fs;self:checklimit(as,as.nactvar+t+1,self.LUAI_MAXVARS,"local variables")as.actvar[as.nactvar+t]=self:registerlocalvar(H,name)end;function d:adjustlocalvars(H,bs)local as=H.fs;as.nactvar=as.nactvar+bs;for Z=bs,1,-1 do self:getlocvar(as,as.nactvar-Z).startpc=as.pc end end;function d:removevars(H,bt)local as=H.fs;while as.nactvar>bt do as.nactvar=as.nactvar-1;self:getlocvar(as,as.nactvar).endpc=as.pc end end;function d:indexupvalue(as,name,y)local ao=as.f;for Z=0,ao.nups-1 do if as.upvalues[Z].k==y.k and as.upvalues[Z].info==y.info then j(ao.upvalues[Z]==name)return Z end end;self:checklimit(as,ao.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(as.L,ao.upvalues,ao.nups,ao.sizeupvalues,nil,self.MAX_INT,"")ao.upvalues[ao.nups]=name;j(y.k=="VLOCAL"or y.k=="VUPVAL")as.upvalues[ao.nups]={k=y.k,info=y.info}local bu=ao.nups;ao.nups=ao.nups+1;return bu end;function d:searchvar(as,t)for Z=as.nactvar-1,0,-1 do if t==self:getlocvar(as,Z).varname then return Z end end;return-1 end;function d:markupval(as,bv)local bw=as.bl;while bw and bw.nactvar>bv do bw=bw.previous end;if bw then bw.upval=true end end;function d:singlevaraux(as,t,b2,bi)if as==nil then self:init_exp(b2,"VGLOBAL",f.NO_REG)return"VGLOBAL"else local y=self:searchvar(as,t)if y>=0 then self:init_exp(b2,"VLOCAL",y)if bi==0 then self:markupval(as,y)end;return"VLOCAL"else if self:singlevaraux(as.prev,t,b2,0)=="VGLOBAL"then return"VGLOBAL"end;b2.info=self:indexupvalue(as,t,b2)b2.k="VUPVAL"return"VUPVAL"end end end;function d:singlevar(H,b2)local bq=self:str_checkname(H)local as=H.fs;if self:singlevaraux(as,bq,b2,1)=="VGLOBAL"then b2.info=h:stringK(as,bq)end end;function d:adjust_assign(H,bs,bx,at)local as=H.fs;local by=bs-bx;if self:hasmultret(at.k)then by=by+1;if by<=0 then by=0 end;h:setreturns(as,at,by)if by>1 then h:reserveregs(as,by-1)end else if at.k~="VVOID"then h:exp2nextreg(as,at)end;if by>0 then local aM=as.freereg;h:reserveregs(as,by)h:_nil(as,aM,by)end end end;function d:enterlevel(H)H.L.nCcalls=H.L.nCcalls+1;if H.L.nCcalls>self.LUAI_MAXCCALLS then e:lexerror(H,"chunk has too many syntax levels",0)end end;function d:leavelevel(H)H.L.nCcalls=H.L.nCcalls-1 end;function d:enterblock(as,bw,bz)bw.breaklist=h.NO_JUMP;bw.isbreakable=bz;bw.nactvar=as.nactvar;bw.upval=false;bw.previous=as.bl;as.bl=bw;j(as.freereg==as.nactvar)end;function d:leaveblock(as)local bw=as.bl;as.bl=bw.previous;self:removevars(as.ls,bw.nactvar)if bw.upval then h:codeABC(as,"OP_CLOSE",bw.nactvar,0,0)end;j(not bw.isbreakable or not bw.upval)j(bw.nactvar==as.nactvar)as.freereg=as.nactvar;h:patchtohere(as,bw.breaklist)end;function d:pushclosure(H,b5,y)local as=H.fs;local ao=as.f;self:growvector(H.L,ao.p,as.np,ao.sizep,nil,f.MAXARG_Bx,"constant table overflow")ao.p[as.np]=b5.f;as.np=as.np+1;self:init_exp(y,"VRELOCABLE",h:codeABx(as,"OP_CLOSURE",0,as.np-1))for Z=0,b5.f.nups-1 do local a0=b5.upvalues[Z].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"h:codeABC(as,a0,0,b5.upvalues[Z].info,0)end end;function d:open_func(H,as)local M=H.L;local ao=self:newproto(H.L)as.f=ao;as.prev=H.fs;as.ls=H;as.L=M;H.fs=as;as.pc=0;as.lasttarget=-1;as.jpc=h.NO_JUMP;as.freereg=0;as.nk=0;as.np=0;as.nlocvars=0;as.nactvar=0;as.bl=nil;ao.source=H.source;ao.maxstacksize=2;as.h={}end;function d:close_func(H)local M=H.L;local as=H.fs;local ao=as.f;self:removevars(H,0)h:ret(as,0,0)ao.sizecode=as.pc;ao.sizelineinfo=as.pc;ao.sizek=as.nk;ao.sizep=as.np;ao.sizelocvars=as.nlocvars;ao.sizeupvalues=ao.nups;j(as.bl==nil)H.fs=as.prev;if as then self:anchor_token(H)end end;function d:parser(M,s,l,name)local bA={}bA.t={}bA.lookahead={}local bB={}bB.upvalues={}bB.actvar={}M.nCcalls=0;bA.buff=l;e:setinput(M,bA,s,name)self:open_func(bA,bB)bB.f.is_vararg=self.VARARG_ISVARARG;e:next(bA)self:chunk(bA)self:check(bA,"TK_EOS")self:close_func(bA)j(bB.prev==nil)j(bB.f.nups==0)j(bA.fs==nil)return bB.f end;function d:field(H,y)local as=H.fs;local b4={}h:exp2anyreg(as,y)e:next(H)self:checkname(H,b4)h:indexed(as,y,b4)end;function d:yindex(H,y)e:next(H)self:expr(H,y)h:exp2val(H.fs,y)self:checknext(H,"]")end;function d:recfield(H,bC)local as=H.fs;local aM=H.fs.freereg;local b4,bD={},{}if H.t.token=="TK_NAME"then self:checklimit(as,bC.nh,self.MAX_INT,"items in a constructor")self:checkname(H,b4)else self:yindex(H,b4)end;bC.nh=bC.nh+1;self:checknext(H,"=")local bE=h:exp2RK(as,b4)self:expr(H,bD)h:codeABC(as,"OP_SETTABLE",bC.t.info,bE,h:exp2RK(as,bD))as.freereg=aM end;function d:closelistfield(as,bC)if bC.v.k=="VVOID"then return end;h:exp2nextreg(as,bC.v)bC.v.k="VVOID"if bC.tostore==f.LFIELDS_PER_FLUSH then h:setlist(as,bC.t.info,bC.na,bC.tostore)bC.tostore=0 end end;function d:lastlistfield(as,bC)if bC.tostore==0 then return end;if self:hasmultret(bC.v.k)then h:setmultret(as,bC.v)h:setlist(as,bC.t.info,bC.na,self.LUA_MULTRET)bC.na=bC.na-1 else if bC.v.k~="VVOID"then h:exp2nextreg(as,bC.v)end;h:setlist(as,bC.t.info,bC.na,bC.tostore)end end;function d:listfield(H,bC)self:expr(H,bC.v)self:checklimit(H.fs,bC.na,self.MAX_INT,"items in a constructor")bC.na=bC.na+1;bC.tostore=bC.tostore+1 end;function d:constructor(H,ae)local as=H.fs;local bh=H.linenumber;local aE=h:codeABC(as,"OP_NEWTABLE",0,0,0)local bC={}bC.v={}bC.na,bC.nh,bC.tostore=0,0,0;bC.t=ae;self:init_exp(ae,"VRELOCABLE",aE)self:init_exp(bC.v,"VVOID",0)h:exp2nextreg(H.fs,ae)self:checknext(H,"{")repeat j(bC.v.k=="VVOID"or bC.tostore>0)if H.t.token=="}"then break end;self:closelistfield(as,bC)local O=H.t.token;if O=="TK_NAME"then e:lookahead(H)if H.lookahead.token~="="then self:listfield(H,bC)else self:recfield(H,bC)end elseif O=="["then self:recfield(H,bC)else self:listfield(H,bC)end until not self:testnext(H,",")and not self:testnext(H,";")self:check_match(H,"}","{",bh)self:lastlistfield(as,bC)f:SETARG_B(as.f.code[aE],self:int2fb(bC.na))f:SETARG_C(as.f.code[aE],self:int2fb(bC.nh))end;function d:parlist(H)local as=H.fs;local ao=as.f;local bF=0;ao.is_vararg=0;if H.t.token~=")"then repeat local O=H.t.token;if O=="TK_NAME"then self:new_localvar(H,self:str_checkname(H),bF)bF=bF+1 elseif O=="TK_DOTS"then e:next(H)self:new_localvarliteral(H,"arg",bF)bF=bF+1;ao.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;ao.is_vararg=ao.is_vararg+self.VARARG_ISVARARG else e:syntaxerror(H,"<name> or "..self:LUA_QL("...").." expected")end until ao.is_vararg~=0 or not self:testnext(H,",")end;self:adjustlocalvars(H,bF)ao.numparams=as.nactvar-ao.is_vararg%self.HASARG_MASK;h:reserveregs(as,as.nactvar)end;function d:body(H,at,bG,bh)local bH={}bH.upvalues={}bH.actvar={}self:open_func(H,bH)bH.f.lineDefined=bh;self:checknext(H,"(")if bG then self:new_localvarliteral(H,"self",0)self:adjustlocalvars(H,1)end;self:parlist(H)self:checknext(H,")")self:chunk(H)bH.f.lastlinedefined=H.linenumber;self:check_match(H,"TK_END","TK_FUNCTION",bh)self:close_func(H)self:pushclosure(H,bH,at)end;function d:explist1(H,y)local t=1;self:expr(H,y)while self:testnext(H,",")do h:exp2nextreg(H.fs,y)self:expr(H,y)t=t+1 end;return t end;function d:funcargs(H,ao)local as=H.fs;local bI={}local bF;local bh=H.linenumber;local O=H.t.token;if O=="("then if bh~=H.lastline then e:syntaxerror(H,"ambiguous syntax (function call x new statement)")end;e:next(H)if H.t.token==")"then bI.k="VVOID"else self:explist1(H,bI)h:setmultret(as,bI)end;self:check_match(H,")","(",bh)elseif O=="{"then self:constructor(H,bI)elseif O=="TK_STRING"then self:codestring(H,bI,H.t.seminfo)e:next(H)else e:syntaxerror(H,"function arguments expected")return end;j(ao.k=="VNONRELOC")local bi=ao.info;if self:hasmultret(bI.k)then bF=self.LUA_MULTRET else if bI.k~="VVOID"then h:exp2nextreg(as,bI)end;bF=as.freereg-(bi+1)end;self:init_exp(ao,"VCALL",h:codeABC(as,"OP_CALL",bi,bF+1,2))h:fixline(as,bh)as.freereg=bi+1 end;function d:prefixexp(H,y)local O=H.t.token;if O=="("then local bh=H.linenumber;e:next(H)self:expr(H,y)self:check_match(H,")","(",bh)h:dischargevars(H.fs,y)elseif O=="TK_NAME"then self:singlevar(H,y)else e:syntaxerror(H,"unexpected symbol")end;return end;function d:primaryexp(H,y)local as=H.fs;self:prefixexp(H,y)while true do local O=H.t.token;if O=="."then self:field(H,y)elseif O=="["then local b4={}h:exp2anyreg(as,y)self:yindex(H,b4)h:indexed(as,y,b4)elseif O==":"then local b4={}e:next(H)self:checkname(H,b4)h:_self(as,y,b4)self:funcargs(H,y)elseif O=="("or O=="TK_STRING"or O=="{"then h:exp2nextreg(as,y)self:funcargs(H,y)else return end end end;function d:simpleexp(H,y)local O=H.t.token;if O=="TK_NUMBER"then self:init_exp(y,"VKNUM",0)y.nval=H.t.seminfo elseif O=="TK_STRING"then self:codestring(H,y,H.t.seminfo)elseif O=="TK_NIL"then self:init_exp(y,"VNIL",0)elseif O=="TK_TRUE"then self:init_exp(y,"VTRUE",0)elseif O=="TK_FALSE"then self:init_exp(y,"VFALSE",0)elseif O=="TK_DOTS"then local as=H.fs;self:check_condition(H,as.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bJ=as.f.is_vararg;if bJ>=self.VARARG_NEEDSARG then as.f.is_vararg=bJ-self.VARARG_NEEDSARG end;self:init_exp(y,"VVARARG",h:codeABC(as,"OP_VARARG",0,1,0))elseif O=="{"then self:constructor(H,y)return elseif O=="TK_FUNCTION"then e:next(H)self:body(H,y,false,H.linenumber)return else self:primaryexp(H,y)return end;e:next(H)end;function d:getunopr(aa)if aa=="TK_NOT"then return"OPR_NOT"elseif aa=="-"then return"OPR_MINUS"elseif aa=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;d.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function d:getbinopr(aa)local bK=self.getbinopr_table[aa]if bK then return bK else return"OPR_NOBINOPR"end end;d.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}d.UNARY_PRIORITY=8;function d:subexpr(H,y,bm)self:enterlevel(H)local bL=self:getunopr(H.t.token)if bL~="OPR_NOUNOPR"then e:next(H)self:subexpr(H,y,self.UNARY_PRIORITY)h:prefix(H.fs,bL,y)else self:simpleexp(H,y)end;local aa=self:getbinopr(H.t.token)while aa~="OPR_NOBINOPR"and self.priority[h.BinOpr[aa]+1][1]>bm do local bb={}e:next(H)h:infix(H.fs,aa,y)local bM=self:subexpr(H,bb,self.priority[h.BinOpr[aa]+1][2])h:posfix(H.fs,aa,y,bb)aa=bM end;self:leavelevel(H)return aa end;function d:expr(H,y)self:subexpr(H,y,0)end;function d:block_follow(I)if I=="TK_ELSE"or I=="TK_ELSEIF"or I=="TK_END"or I=="TK_UNTIL"or I=="TK_EOS"then return true else return false end end;function d:block(H)local as=H.fs;local bw={}self:enterblock(as,bw,false)self:chunk(H)j(bw.breaklist==h.NO_JUMP)self:leaveblock(as)end;function d:check_conflict(H,bN,y)local as=H.fs;local by=as.freereg;local bO=false;while bN do if bN.v.k=="VINDEXED"then if bN.v.info==y.info then bO=true;bN.v.info=by end;if bN.v.aux==y.info then bO=true;bN.v.aux=by end end;bN=bN.prev end;if bO then h:codeABC(as,"OP_MOVE",as.freereg,y.info,0)h:reserveregs(as,1)end end;function d:assignment(H,bN,bs)local at={}local O=bN.v.k;self:check_condition(H,O=="VLOCAL"or O=="VUPVAL"or O=="VGLOBAL"or O=="VINDEXED","syntax error")if self:testnext(H,",")then local bP={}bP.v={}bP.prev=bN;self:primaryexp(H,bP.v)if bP.v.k=="VLOCAL"then self:check_conflict(H,bN,bP.v)end;self:checklimit(H.fs,bs,self.LUAI_MAXCCALLS-H.L.nCcalls,"variables in assignment")self:assignment(H,bP,bs+1)else self:checknext(H,"=")local bx=self:explist1(H,at)if bx~=bs then self:adjust_assign(H,bs,bx,at)if bx>bs then H.fs.freereg=H.fs.freereg-(bx-bs)end else h:setoneret(H.fs,at)h:storevar(H.fs,bN.v,at)return end end;self:init_exp(at,"VNONRELOC",H.fs.freereg-1)h:storevar(H.fs,bN.v,at)end;function d:cond(H)local y={}self:expr(H,y)if y.k=="VNIL"then y.k="VFALSE"end;h:goiftrue(H.fs,y)return y.f end;function d:breakstat(H)local as=H.fs;local bw=as.bl;local bQ=false;while bw and not bw.isbreakable do if bw.upval then bQ=true end;bw=bw.previous end;if not bw then e:syntaxerror(H,"no loop to break")end;if bQ then h:codeABC(as,"OP_CLOSE",bw.nactvar,0,0)end;bw.breaklist=h:concat(as,bw.breaklist,h:jump(as))end;function d:whilestat(H,bh)local as=H.fs;local bw={}e:next(H)local bR=h:getlabel(as)local bS=self:cond(H)self:enterblock(as,bw,true)self:checknext(H,"TK_DO")self:block(H)h:patchlist(as,h:jump(as),bR)self:check_match(H,"TK_END","TK_WHILE",bh)self:leaveblock(as)h:patchtohere(as,bS)end;function d:repeatstat(H,bh)local as=H.fs;local bT=h:getlabel(as)local bU,bV={},{}self:enterblock(as,bU,true)self:enterblock(as,bV,false)e:next(H)self:chunk(H)self:check_match(H,"TK_UNTIL","TK_REPEAT",bh)local bS=self:cond(H)if not bV.upval then self:leaveblock(as)h:patchlist(H.fs,bS,bT)else self:breakstat(H)h:patchtohere(H.fs,bS)self:leaveblock(as)h:patchlist(H.fs,h:jump(as),bT)end;self:leaveblock(as)end;function d:exp1(H)local at={}self:expr(H,at)local aU=at.k;h:exp2nextreg(H.fs,at)return aU end;function d:forbody(H,bi,bh,bs,bW)local bw={}local as=H.fs;self:adjustlocalvars(H,3)self:checknext(H,"TK_DO")local bX=bW and h:codeAsBx(as,"OP_FORPREP",bi,h.NO_JUMP)or h:jump(as)self:enterblock(as,bw,false)self:adjustlocalvars(H,bs)h:reserveregs(as,bs)self:block(H)self:leaveblock(as)h:patchtohere(as,bX)local bY=bW and h:codeAsBx(as,"OP_FORLOOP",bi,h.NO_JUMP)or h:codeABC(as,"OP_TFORLOOP",bi,0,bs)h:fixline(as,bh)h:patchlist(as,bW and bY or h:jump(as),bX+1)end;function d:fornum(H,bq,bh)local as=H.fs;local bi=as.freereg;self:new_localvarliteral(H,"(for index)",0)self:new_localvarliteral(H,"(for limit)",1)self:new_localvarliteral(H,"(for step)",2)self:new_localvar(H,bq,3)self:checknext(H,'=')self:exp1(H)self:checknext(H,",")self:exp1(H)if self:testnext(H,",")then self:exp1(H)else h:codeABx(as,"OP_LOADK",as.freereg,h:numberK(as,1))h:reserveregs(as,1)end;self:forbody(H,bi,bh,1,true)end;function d:forlist(H,bZ)local as=H.fs;local at={}local bs=0;local bi=as.freereg;self:new_localvarliteral(H,"(for generator)",bs)bs=bs+1;self:new_localvarliteral(H,"(for state)",bs)bs=bs+1;self:new_localvarliteral(H,"(for control)",bs)bs=bs+1;self:new_localvar(H,bZ,bs)bs=bs+1;while self:testnext(H,",")do self:new_localvar(H,self:str_checkname(H),bs)bs=bs+1 end;self:checknext(H,"TK_IN")local bh=H.linenumber;self:adjust_assign(H,3,self:explist1(H,at),at)h:checkstack(as,3)self:forbody(H,bi,bh,bs-3,false)end;function d:forstat(H,bh)local as=H.fs;local bw={}self:enterblock(as,bw,true)e:next(H)local bq=self:str_checkname(H)local O=H.t.token;if O=="="then self:fornum(H,bq,bh)elseif O==","or O=="TK_IN"then self:forlist(H,bq)else e:syntaxerror(H,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(H,"TK_END","TK_FOR",bh)self:leaveblock(as)end;function d:test_then_block(H)e:next(H)local bS=self:cond(H)self:checknext(H,"TK_THEN")self:block(H)return bS end;function d:ifstat(H,bh)local as=H.fs;local b_=h.NO_JUMP;local c0=self:test_then_block(H)while H.t.token=="TK_ELSEIF"do b_=h:concat(as,b_,h:jump(as))h:patchtohere(as,c0)c0=self:test_then_block(H)end;if H.t.token=="TK_ELSE"then b_=h:concat(as,b_,h:jump(as))h:patchtohere(as,c0)e:next(H)self:block(H)else b_=h:concat(as,b_,c0)end;h:patchtohere(as,b_)self:check_match(H,"TK_END","TK_IF",bh)end;function d:localfunc(H)local y,m={},{}local as=H.fs;self:new_localvar(H,self:str_checkname(H),0)self:init_exp(y,"VLOCAL",as.freereg)h:reserveregs(as,1)self:adjustlocalvars(H,1)self:body(H,m,false,H.linenumber)h:storevar(as,y,m)self:getlocvar(as,as.nactvar-1).startpc=as.pc end;function d:localstat(H)local bs=0;local bx;local at={}repeat self:new_localvar(H,self:str_checkname(H),bs)bs=bs+1 until not self:testnext(H,",")if self:testnext(H,"=")then bx=self:explist1(H,at)else at.k="VVOID"bx=0 end;self:adjust_assign(H,bs,bx,at)self:adjustlocalvars(H,bs)end;function d:funcname(H,y)local bG=false;self:singlevar(H,y)while H.t.token=="."do self:field(H,y)end;if H.t.token==":"then bG=true;self:field(H,y)end;return bG end;function d:funcstat(H,bh)local y,m={},{}e:next(H)local bG=self:funcname(H,y)self:body(H,m,bG,bh)h:storevar(H.fs,y,m)h:fixline(H.fs,bh)end;function d:exprstat(H)local as=H.fs;local y={}y.v={}self:primaryexp(H,y.v)if y.v.k=="VCALL"then f:SETARG_C(h:getcode(as,y.v),1)else y.prev=nil;self:assignment(H,y,1)end end;function d:retstat(H)local as=H.fs;local at={}local E,aB;e:next(H)if self:block_follow(H.t.token)or H.t.token==";"then E,aB=0,0 else aB=self:explist1(H,at)if self:hasmultret(at.k)then h:setmultret(as,at)if at.k=="VCALL"and aB==1 then f:SET_OPCODE(h:getcode(as,at),"OP_TAILCALL")j(f:GETARG_A(h:getcode(as,at))==as.nactvar)end;E=as.nactvar;aB=self.LUA_MULTRET else if aB==1 then E=h:exp2anyreg(as,at)else h:exp2nextreg(as,at)E=as.nactvar;j(aB==as.freereg-E)end end end;h:ret(as,E,aB)end;function d:statement(H)local bh=H.linenumber;local O=H.t.token;if O=="TK_IF"then self:ifstat(H,bh)return false elseif O=="TK_WHILE"then self:whilestat(H,bh)return false elseif O=="TK_DO"then e:next(H)self:block(H)self:check_match(H,"TK_END","TK_DO",bh)return false elseif O=="TK_FOR"then self:forstat(H,bh)return false elseif O=="TK_REPEAT"then self:repeatstat(H,bh)return false elseif O=="TK_FUNCTION"then self:funcstat(H,bh)return false elseif O=="TK_LOCAL"then e:next(H)if self:testnext(H,"TK_FUNCTION")then self:localfunc(H)else self:localstat(H)end;return false elseif O=="TK_RETURN"then self:retstat(H)return true elseif O=="TK_BREAK"then e:next(H)self:breakstat(H)return true else self:exprstat(H)return false end end;function d:chunk(H)local c1=false;self:enterlevel(H)while not c1 and not self:block_follow(H.t.token)do c1=self:statement(H)self:testnext(H,";")j(H.fs.f.maxstacksize>=H.fs.freereg and H.fs.freereg>=H.fs.nactvar)H.fs.freereg=H.fs.nactvar end;self:leavelevel(H)end;e:init()local c2={}return function(o,name)name=name or'compiled-lua'local c3=c:init(c:make_getF(o),nil)if not c3 then return end;local b5=d:parser(c2,c3,nil,"@"..name)local af,l=g:make_setS()g:dump(c2,b5,af,l)return l.data end end)()local c4=(function(...)local bit=bit or bit32 or require('bit')if not table.create then function table.create(c)return{}end end;if not table.unpack then table.unpack=unpack end;if not table.pack then function table.pack(...)return{n=select('#',...),...}end end;if not table.move then function table.move(d,e,f,g,h)for i=0,f-e do h[g+i]=d[e+i]end end end;local j;local k;local l;local m=50;local n={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local o={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local p={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function q(d,r,s,t)local u=0;for i=r,s,t do local v=256^math.abs(i-r)u=u+v*string.byte(d,i,i)end;return u end;local function w(y,z,x,A)local B=(-1)^bit.rshift(A,7)local C=bit.rshift(x,7)+bit.lshift(bit.band(A,0x7F),1)local D=y+bit.lshift(z,8)+bit.lshift(bit.band(x,0x7F),16)local E=1;if C==0 then if D==0 then return B*0 else E=0;C=1 end elseif C==0x7F then if D==0 then return B*1/0 else return B*0/0 end end;return B*2^(C-127)*(1+E/2^23)end;local function F(y,z,x,A,G,H,I,J)local B=(-1)^bit.rshift(J,7)local C=bit.lshift(bit.band(J,0x7F),4)+bit.rshift(I,4)local D=bit.band(I,0x0F)*2^48;local E=1;D=D+H*2^40+G*2^32+A*2^24+x*2^16+z*2^8+y;if C==0 then if D==0 then return B*0 else E=0;C=1 end elseif C==0x7FF then if D==0 then return B*1/0 else return B*0/0 end end;return B*2^(C-1023)*(E+D/2^52)end;local function K(d,r,s)return q(d,r,s-1,1)end;local function L(d,r,s)return q(d,s-1,r,-1)end;local function M(d,r)return w(string.byte(d,r,r+3))end;local function N(d,r)local y,z,x,A=string.byte(d,r,r+3)return w(A,x,z,y)end;local function O(d,r)return F(string.byte(d,r,r+7))end;local function P(d,r)local y,z,x,A,G,H,I,J=string.byte(d,r,r+7)return F(J,I,H,G,A,x,z,y)end;local Q={[4]={little=M,big=N},[8]={little=O,big=P}}local function R(S)local T=S.index;local U=string.byte(S.source,T,T)S.index=T+1;return U end;local function V(S,W)local X=S.index+W;local Y=string.sub(S.source,S.index,X-1)S.index=X;return Y end;local function Z(S)local W=S:s_szt()local Y;if W~=0 then Y=string.sub(V(S,W),1,-2)end;return Y end;local function _(W,a0)return function(S)local X=S.index+W;local a1=a0(S.source,S.index,X)S.index=X;return a1 end end;local function a2(W,a0)return function(S)local a3=a0(S.source,S.index)S.index=S.index+W;return a3 end end;local function a4(S)local W=S:s_int()local a5=table.create(W)for i=1,W do local a6=S:s_ins()local a7=bit.band(a6,0x3F)local a8=o[a7]local a9=p[a7]local aa={value=a6,op=n[a7],A=bit.band(bit.rshift(a6,6),0xFF)}if a8=='ABC'then aa.B=bit.band(bit.rshift(a6,23),0x1FF)aa.C=bit.band(bit.rshift(a6,14),0x1FF)aa.is_KB=a9.b=='OpArgK'and aa.B>0xFF;aa.is_KC=a9.c=='OpArgK'and aa.C>0xFF elseif a8=='ABx'then aa.Bx=bit.band(bit.rshift(a6,14),0x3FFFF)aa.is_K=a9.b=='OpArgK'elseif a8=='AsBx'then aa.sBx=bit.band(bit.rshift(a6,14),0x3FFFF)-131071 end;a5[i]=aa end;return a5 end;local function ab(S)local W=S:s_int()local a5=table.create(W)for i=1,W do local ac=R(S)local ad;if ac==1 then ad=R(S)~=0 elseif ac==3 then ad=S:s_num()elseif ac==4 then ad=Z(S)end;a5[i]=ad end;return a5 end;local function ae(S,d)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=l(S,d)end;return a5 end;local function af(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=S:s_int()end;return a5 end;local function ag(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]={varname=Z(S),startpc=S:s_int(),endpc=S:s_int()}end;return a5 end;local function ah(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=Z(S)end;return a5 end;function l(S,ai)local aj={}local d=Z(S)or ai;aj.source=d;S:s_int()S:s_int()aj.num_upval=R(S)aj.num_param=R(S)R(S)aj.max_stack=R(S)aj.code=a4(S)aj.const=ab(S)aj.subs=ae(S,d)aj.lines=af(S)ag(S)ah(S)for c,ak in ipairs(aj.code)do if ak.is_K then ak.const=aj.const[ak.Bx+1]else if ak.is_KB then ak.const_B=aj.const[ak.B-0xFF]end;if ak.is_KC then ak.const_C=aj.const[ak.C-0xFF]end end end;return aj end;function j(d)local al;local am;local an;local ao;local ap;local aq;local ar;local as={index=1,source=d}assert(V(as,4)=='\27Lua','invalid Lua signature')assert(R(as)==0x51,'invalid Lua version')assert(R(as)==0,'invalid Lua format')am=R(as)~=0;an=R(as)ao=R(as)ap=R(as)aq=R(as)ar=R(as)~=0;al=am and K or L;as.s_int=_(an,al)as.s_szt=_(ao,al)as.s_ins=_(ap,al)if ar then as.s_num=_(aq,al)elseif Q[aq]then as.s_num=a2(aq,Q[aq][am and'little'or'big'])else error('unsupported float size')end;return l(as,'@virtual')end;local function at(a5,au)for i,av in pairs(a5)do if av.index>=au then av.value=av.store[av.index]av.store=av;av.index='value'a5[i]=nil end end end;local function aw(a5,au,ax)local ay=a5[au]if not ay then ay={index=au,store=ax}a5[au]=ay end;return ay end;local function az(aA,aB)local d=aA.source;local aC=aA.lines[aA.pc-1]error(string.format('%s:%i: %s',d,aC,aB),0)end;local function aD(aE,aF,aG)local aH=aE.code;local aI=aE.subs;local aJ=aE.vararg;local aK=-1;local aL={}local ax=aE.memory;local aM=aE.pc;while true do local aN=aH[aM]local a7=aN.op;aM=aM+1;if a7<18 then if a7<8 then if a7<3 then if a7<1 then for i=aN.A,aN.B do ax[i]=nil end elseif a7>1 then local av=aG[aN.B]ax[aN.A]=av.store[av.index]else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO+aP end elseif a7>3 then if a7<6 then if a7>4 then local aQ=aN.A;local aR=aN.B;local au;if aN.is_KC then au=aN.const_C else au=ax[aN.C]end;ax[aQ+1]=ax[aR]ax[aQ]=ax[aR][au]else ax[aN.A]=aF[aN.const]end elseif a7>6 then local au;if aN.is_KC then au=aN.const_C else au=ax[aN.C]end;ax[aN.A]=ax[aN.B][au]else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO-aP end else ax[aN.A]=ax[aN.B]end elseif a7>8 then if a7<13 then if a7<10 then aF[aN.const]=ax[aN.A]elseif a7>10 then if a7<12 then local aQ=aN.A;local aR=aN.B;local aS=aN.C;local aT;if aR==0 then aT=aK-aQ else aT=aR-1 end;local aU=table.pack(ax[aQ](table.unpack(ax,aQ+1,aQ+aT)))local aV=aU.n;if aS==0 then aK=aQ+aV-1 else aV=aS-1 end;table.move(aU,1,aV,aQ,ax)else local av=aG[aN.B]av.store[av.index]=ax[aN.A]end else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO*aP end elseif a7>13 then if a7<16 then if a7>14 then local aQ=aN.A;local aR=aN.B;local aT;if aR==0 then aT=aK-aQ else aT=aR-1 end;at(aL,0)return ax[aQ](table.unpack(ax,aQ+1,aQ+aT))else local au,aW;if aN.is_KB then au=aN.const_B else au=ax[aN.B]end;if aN.is_KC then aW=aN.const_C else aW=ax[aN.C]end;ax[aN.A][au]=aW end elseif a7>16 then ax[aN.A]={}else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO/aP end else ax[aN.A]=aN.const end else local aQ=aN.A;local aX=ax[aQ+2]local au=ax[aQ]+aX;local aY=ax[aQ+1]local aZ;if aX==math.abs(aX)then aZ=au<=aY else aZ=au>=aY end;if aZ then ax[aN.A]=au;ax[aN.A+3]=au;aM=aM+aN.sBx end end elseif a7>18 then if a7<28 then if a7<23 then if a7<20 then ax[aN.A]=#ax[aN.B]elseif a7>20 then if a7<22 then local aQ=aN.A;local aR=aN.B;local W;if aR==0 then W=aK-aQ+1 else W=aR-1 end;at(aL,0)return table.unpack(ax,aQ,aQ+W-1)else local Y=ax[aN.B]for i=aN.B+1,aN.C do Y=Y..ax[i]end;ax[aN.A]=Y end else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO%aP end elseif a7>23 then if a7<26 then if a7>24 then at(aL,aN.A)else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO==aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 end elseif a7>26 then local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO<aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO^aP end else ax[aN.A]=aN.B~=0;if aN.C~=0 then aM=aM+1 end end elseif a7>28 then if a7<33 then if a7<30 then local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO<=aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 elseif a7>30 then if a7<32 then local a_=aI[aN.Bx+1]local b0=a_.num_upval;local b1;if b0~=0 then b1={}for i=1,b0 do local b2=aH[aM+i-1]if b2.op==n[0]then b1[i-1]=aw(aL,b2.B,ax)elseif b2.op==n[4]then b1[i-1]=aG[b2.B]end end;aM=aM+b0 end;ax[aN.A]=k(a_,aF,b1)else local aQ=aN.A;local aR=aN.B;if not ax[aR]~=(aN.C~=0)then ax[aQ]=ax[aR]aM=aM+aH[aM].sBx end;aM=aM+1 end else ax[aN.A]=-ax[aN.B]end elseif a7>33 then if a7<36 then if a7>34 then local aQ=aN.A;local W=aN.B;if W==0 then W=aJ.len;aK=aQ+W-1 end;table.move(aJ.list,1,W,aQ,ax)else local aQ=aN.A;local b3,aY,aX;b3=assert(tonumber(ax[aQ]),'`for` initial value must be a number')aY=assert(tonumber(ax[aQ+1]),'`for` limit must be a number')aX=assert(tonumber(ax[aQ+2]),'`for` step must be a number')ax[aQ]=b3-aX;ax[aQ+1]=aY;ax[aQ+2]=aX;aM=aM+aN.sBx end elseif a7>36 then local aQ=aN.A;local aS=aN.C;local W=aN.B;local b4=ax[aQ]local g;if W==0 then W=aK-aQ end;if aS==0 then aS=aN[aM].value;aM=aM+1 end;g=(aS-1)*m;table.move(ax,aQ+1,aQ+W,g+1,b4)else ax[aN.A]=not ax[aN.B]end else if not ax[aN.A]~=(aN.C~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 end else local aQ=aN.A;local b5=aQ+3;local b6={ax[aQ](ax[aQ+1],ax[aQ+2])}table.move(b6,1,aN.C,b5,ax)if ax[b5]~=nil then ax[aQ+2]=ax[b5]aM=aM+aH[aM].sBx end;aM=aM+1 end else aM=aM+aN.sBx end;aE.pc=aM end end;function k(aj,aF,b7)local function b8(...)local b9=table.pack(...)local ax=table.create(aj.max_stack)local aJ={len=0,list={}}table.move(b9,1,aj.num_param,0,ax)if aj.num_param<b9.n then local ba=aj.num_param+1;local W=b9.n-aj.num_param;aJ.len=W;table.move(b9,ba,ba+W-1,1,aJ.list)end;local aE={vararg=aJ,memory=ax,code=aj.code,subs=aj.subs,pc=1}local bb=table.pack(pcall(aD,aE,aF,b7))if bb[1]then return table.unpack(bb,2,bb.n)else local aA={pc=aE.pc,source=aj.source,lines=aj.lines}az(aA,bb[2])return end end;return b8 end;return function(bc,aF)return k(j(bc),aF or getfenv(0))end end)()getfenv().script=nil;return function(c5,c6)local c7;local c6=c6 or getfenv(2)local name=c6.script and c6.script:GetFullName()local c8,c9=pcall(function()local ca=b(c5,name)c7=c4(ca,c6)end)if c8 then return setfenv(c7,c6)end;return nil,c9 end end)();local function lZ(c)local r={}for i=1,#c,6 do r[#r+1]=ke(oU(pM(c,i,i+3))-dOO)end return sQ(r) end;local H=[=[l9,P,Q,I=select,1,nil,nil,nil;repeat if l9<=0x000 then Q=Jf;l9=2;else if l9==0X1 then P={[0]={[0X00000]=Af,0X1,2,Bf,4,ff,0X006,7,Of,0X09,10,0X000B,12,0X000d,14,0XF},{[0]=1,0,3,2,5,4,7,6,0X00009,0X8,0Xb,10,0X00d,12,15,Vf},{[0]=2,3,0X00,0X1,6,0X7,4,5,0XA,0x000b,8,nf,0XE,0xf,0Xc,0X00d},{[0]=0X3,2,1,0X0,bf,6,5,0x0004,0X00B,0Xa,9,0x8,0Xf,0X000e,0xd,0xc},{[0]=4,5,6,7,0,0X001,0X002,0X3,12,0x000d,0X0E,0X0F,0X8,9,10,0xB},{[0]=ff,4,7,6,1,0,0X0003,2,Df,12,0X0000F,14,0X00009,Of,0X0B,10},{[0]=6,7,4,0x5,2,3,0X000,0X001,14,0XF,0Xc,13,10,0X0b,8,nf},{[0X00]=0X7,6,5,jf,3,2,0X1,0,0Xf,14,0xd,0Xc,11,10,9,0x8},{[0]=8,9,0x0a,0xb,12,Df,14,Ef,0,1,0x2,3,0x4,5,0x006,7},{[0]=0X9,0x00008,0XB,10,0X0D,0XC,15,Vf,0X01,0x0000,0X003,vf,0X5,4,0X07,6},{[0X00000]=0xA,0xb,0X8,nf,14,15,0X00C,13,0x2,0X003,0X0,0x0001,6,0x7,0X4,0X5},{[0]=11,0Xa,9,8,0X0000f,0XE,13,0X00C,3,0X2,0x0001,0,0X00007,xf,ff,0X4},{[0X0]=0X0000c,0x0D,0Xe,0X0000F,8,0X00009,0Xa,11,jf,5,xf,0X7,0X0,0X001,0x2,0x3},{[0X0000]=Df,0X00c,0X000f,0Xe,nf,0X8,0XB,10,5,4,bf,6,1,0X0,3,vf},{[0]=14,15,12,13,Ff,0xB,0X08,9,0X006,7,4,0x0005,2,3,0,1},{[0]=0X0F,14,0Xd,0XC,0XB,0Xa,9,0X00008,0X7,6,0X5,0x4,Bf,2,0X0001,0}};l9=0X000;else I=mf;l9=0X3;end;end;until l9>=3]=];local WW=('0450DD0448HE0463EE0450AB0448AB0457EH0465DH0387EB0388HB0393AD0431HE0461EH0452DB0459EB0442EE0419AH0464AE0445EE0442BE0417AD0461HE0448DD0448AB0442EB0423BH0458DA0444AD0447AD0448EB0461DB0379DA0408EB0379EE0463ED0461AB0464DA0448BD0357EB0455EE0458EA0446BH0444HA0455EH0379BE0417EE0461HB0448BH0448BA0417BA0458AH0455EB0447BE0448AE0461BA0379AE0408BE0379BH0381AE0451AE0463DB0463AH0459DA0462BD0405BE0394HE0394AE0461DH0444ED0466AB0393DD0450DE0452AE0463EB0451AA0464AE0445BB0464AD0462DH0448ED0461HH0446EA0458DB0457ED0463EA0448AA0457AD0463EE0393EE0446AE0458DD0456EE0394DE0448AE0455ED0467AE0458AD0446ED0444AD0462DD0435BE0415BB0394AA0431EE0461DB0452HE0459EE0392DA0419DA0464AA0445HA0394DA0456AE0444EE0452EB0457EB0394EB0417HD0461AB0448AD0448DB0394AH0381EA0357EE0357DD0452EB0449BD0379EH0450DE0444BB0456BH0448DD0393DE0427EH0455ED0444HE0446AD0448AE0420BB0447HA0379AE0408EB0408EE0379BA0400DH0401BD0395AE0397ED0395HE0400DH0400HH0398BE0404EA0399HH0379BH0463DD0451EB0448HE0457HH0379EH0379BA0379BA0379EE0379EH0357BD0379EH0379EH0379BE0379BH0379AB0379HB0379EA0379EA0379EA0379AH0379DD0379BB0379HE0379BH0379BH0379HE0379AD0379BB0379DE0379DH0379BD0379BH0379AB0379AH0379HD0379EA0379BH0379HE0379EE0379BD0379BD0379HE0379AE0379DE0379EH0379BB0379EB0379AH0379EH0357BE0455AD0458DA0444AE0447EB0462ED0463AD0461AE0452EE0457AB0450EH0387DA0450HD0444ED0456ED0448HA0405BA0419EE0463AA0463BE0459EE0418HH0448ED0463AB0387DD0417BD0461BE0448ED0448AH0417EH0458EH0455DA0447HB0448EB0461AD0393BE0393BE0381DE0419EH0458BA0458HD0447BD0424EB0458EE0447HA0447HA0448EE0447BA0393DE0455HH0464HE0444HD0381HA0388DE0388HA0387HH0388ED0357DH0379BE0379AB0379ED0379BD0379EB0379EB0379HB0379ED0379EB0379HE0379EE0379BB0379DA0379BD0379AE0379EA0379HB0379ED0379HB0379DD0379BB0379EE0379EA0379AH0379AE0379BE0379DB0379ED0379AE0379AE0379EA0379DE0379DE0379DE0379AE0379EB0379BA0379HB0379ED0379AA0379HB0379ED0379EE0357BB0448HB0455AB0462AH0448BB0452DE0449EH0379BE0450AE0444HE0456DH0448BD0393DE0427EB0455HD0444AE0446BE0448EE0420AA0447BE0379DE0408HD0408EE0379ED0396DE0397BB0403EE0396HE0400BH0398AH0401EH0403EB0402BE0402ED0404BA0379BE0463DE0451DH0448BD0457DE0379AE0357EE0357EB0455ED0458AD0444AD0447ED0462DE0463ED0461HE0452HE0457EB0450HH0387BE0450HB0444EH0456HH0448BE0405EB0419EE0463DA0463DE0459HH0418EE0448EE0463DH0387HH0417EE0461BB0448ED0448HD0417AE0458HB0455EE0447EH0448HE0461BE0393ED0393HD0381AE0415HD0444ED0419AE0458ED0458HE0447AB0412DE0452AE0456BA0431AH0461DB0444AD0452DB0457EH0448EE0461AE0393BH0455EB0464AA0444BE0381DA0388DB0388DB0387DA0388HE0357AA0357EE0448AE0455AB0462EE0448DA0452EA0449BE0379BA0450HE0444DH0456AD0448AE0393BA0427BE0455EB0444EA0446HE0448EE0420EH0447ED0379AB0408DA0408EE0379EA0404AA0403BE0397EA0400HE0400EA0396AD0400EA0398EH0400DA0401AE0379AA0463DB0451EE0448BE0457HE0357BE0357DD0455HH0458EE0444DB0447DA0462EE0463BE0461ED0452AE0457EH0450EB0387EE0450AD0444HD0456AE0448AA0405EA0419EH0463AE0463HA0459ED0418BA0448EE0463DE0387DA0417DD0461DH0448DE0448DH0417AD0458EB0455EE0447DE0448DH0461EH0393BE0393AE0381DH0419BE0458BA0458AA0447AD0414EA0464BA0462EA0463EE0458AB0456BH0462BB0393BH0455AB0464BD0444HE0381ED0388AA0388DA0387AD0388EB0379DA0357BD0357HE0448BD0455EA0462EE0448AB0452EA0449AA0379DE0450EE0444HB0456BD0448BH0393DE0427AE0455HE0444EB0446EH0448EH0420BE0447EE0379EB0408DE0408EH0379HD0396EA0397BD0402HA0400BA0398DA0396EA0399AH0403AD0396EA0398HE0397BB0379BE0463BB0451EA0448AA0457EE0357EB0357EA0455BA0458AH0444DH0447AE0462EB0463EH0461EH0452HA0457AE0450AH0387HE0450DH0444BD0456DE0448EE0405ED0419EB0463EB0463BE0459EE0418AB0448EE0463HB0387EH0417BB0461BB0448AB0448BB0417AE0458EA0455EE0447AB0448HE0461EE0393AD0393HE0381AE0415AE0444HA0414AD0444EE0462HA0452BE0457EA0458EA0393HD0455HH0464AE0444BD0381DB0388DE0388BE0387BD0388EB0379HE0379ED0379EH0379BE0357BA0357EH0448HE0455BA0462AA0448DH0452HD0449DH0379ED0450EB0444DE0456HH0448AB0393EE0427DE0455EE0444HA0446EA0448EA0420EH0447EH0379AE0408EE0408AH0379HA0397EE0402BA0403HH0403BD0397HE0397AH0404EB0398AH0402HA0401BH0379DA0463HH0451AD0448EH0457HH0357DE0357EH0455EE0458DA0444AB0447HE0462EE0463DE0461AB0452EE0457ED0450AD0387EE0450AE0444EE0456HH0448DE0405HB0419AH0463AH0463EB0459AA0418AE0448BD0463DD0387DE0417BB0461HH0448HH0448DA0417AA0458DE0455AD0447DD0448DH0461EA0393AB0393HE0381EB0415DE0444AD0419HH0458DA0458EA0447EA0393AE0455DE0464EE0444HE0381AB0388AA0388HD0387EE0388BH0379EE0379EA0379BA0379EH0357HA0357AB0448HB0455BA0462AE0448EH0357EE0357EA0455AA0458HH0444HH0447BE0462HE0463EA0461BE0452EH0457HE0450ED0387HA0450AA0444BH0456ED0448AE0405EH0419EA0463HA0463HH0459EB0418EH0448AD0463DH0387HH0417EB0461HA0448EB0448BE0417AD0458HE0455BE0447EA0448AB0461HE0393DH0393AE0381EE0419BE0458EE0458EE0447HE0424AB0458DH0447HD0447DD0448DD0447EE0393ED0455EA0464EA0444AD0381DE0388BE0388EH0387BE0388EA0357HD0357AE0448EA0457BH0447EA0357AB0357HE0357HA0455AH0458DA0444BH0447HH0462AA0463AA0461EA0452BD0457EE0450EE0387ED0450DB0444BE0456EH0448EE0405EA0419AA0463DE0463DD0459HB0418AD0448BD0463DD0387BA0381EH0451AB0463HD0463ED0459DB0462AE0405ED0394HD0394BA0461DH0444AE0466HB0393EB0450DA0452AB0463BE0451AD0464DB0445EB0464EB0462AE0448BE0461BE0446ED0458HD0457HH0463DA0448AE0457HE0463EH0393AD0446EA0458BE0456ED0394HH0448DE0455AD0467EB0458EH0446EH0444HE0462HB0435AH0415AD0394AA0431HD0461EE0452HE0459EE0392AH0419AA0464DA0445EB0394HE0456DD0444HB0452HB0457BA0394DE0430BH0446EH0461EA0452AH0459BE0463DA0462DE0394HA0434EA0448HH0445BD0451BA0458BB0458DH0454DE0393HD0455BA0464AA0444ED0381HD0388AH0388HB0387EB0388BH0357ED');local a,wn,wu=[=[function(HB,KB)do if KB=="H"then Y=S(HB);do return"";end;else local mA=T(S(HB..KB,16));do if not(Y)then return mA;else local qQ=(c(mA,Y));Y=nil;do return qQ;end;end;end;end;end;end));do NB=2;end;local g,q,a=nil,nil,nil;do repeat do if not(NB<=0)then if NB==0X01 then do a=function(HE,JE,SE)local nE,OE=0X1,(nil);while 0.13933850539849768 do do if nE<=0x0 then OE=SE-JE+1;do break;end;else if nE==0X1 then if not(not JE)then else JE=0X00001;end;nE=0X2;else if not SE then do SE=#HE;end;end;nE=0X0;end;end;end;end;if OE>0X1F3d then do return m(HE,JE,SE);end;else return z(HE,JE,SE);end;end;end;do break;end;else g=lr;do NB=0;end;end;else do q=Hr;end;do NB=0x1;end;end;end;until false;end;local C=({[0X000]=0X00001,0X2,0X4,Yr,16,32,0X40,0x80,0X000100,512,0X0400,0X800,4096,8192,0X4000,32768,65536,131072,262144,0X000080000,1048576,0X200000,4194304,hr,0X1000000,0X2000000,jr,134217728,Xr,0X20000000,1073741824,w,t,[35]=34359738368,[42]=4398046511104,[49]=562949953421312});NB=1;local x,o=nil,(nil);while NB~=2 do if NB==0x0 then do o=UB;end;NB=2;else x=(Pr or bit32);NB=0;end;end;local D=x and x[iB]or function(uj,dj)local Hj,lj=nil,(nil);do for oC=0,0x00005 do do if not(oC<=2)then do if oC<=3 then lj=Br;else if oC==0x04 then do while uj>0X0 and dj>0 do local mC,oC,iC=3,nil,(nil);while mC<=0x0005 do do if not(mC<=0X2)then if mC<=0x3 then oC=uj%0X000010;do mC=0x2;end;else if mC==4 then lj=lj+s[oC][iC]*Hj;mC=5;else uj=(uj-oC)/16;mC=0X00;end;end;else if mC<=0X0 then do dj=(dj-iC)/16;end;mC=0X1;else if mC~=0X01 then do iC=dj%0X10;end;mC=4;else Hj=Hj*0X10;mC=0X6;end;end;end;end;end;end;end;else return lj+uj*Hj+dj*Hj;end;end;end;else if oC<=0 then uj=uj%t;else if oC==0X1 then Hj=1;else dj=dj%t;end;end;end;end;end;end;end;local r=(x and x.band or function(iV,VV)do iV=iV%t;end;local WV=(0);while'\119\093\068\087\051{)?'do if WV~=0x0 then return((iV+VV)-D(iV,VV))/2;else VV=VV%t;WV=1;end;end;end);local V=x and x.bor or function(Hz,Xz)for pR=0,2 do if pR<=0 then Hz=Hz%t;elseif pR~=0X1 then return f-r(f-Hz,f-Xz);else do Xz=Xz%t;end;end;end;end;local A=(x and x[GB]or function(Y1)return f-(Y1%t);end);NB=1;local ur,k=nil,nil;while NB~=2 do do if NB~=0x0 then ur=function()(v)("\089o\117r\032\101n\118\105\114o\110me\110\116\032do\101\115\032no\116\032\115\117p\112o\114\116\032Lua\074\073\084\039\115\032FFI\032\108i\098rar\121\044\032t\104ere\102\111re\032you\032\099\097nn\111t\032\117\115\101\032L\076/\085\076\076\047i \115uf\102i\120es\046");end;NB=0X0000;else k=function(...)do return(...)[...];end;end;NB=2;end;end;end;local l,H=x and x[eB],x and x[RB];l=l or function(ns,rs)do if rs>=SB then return 0;end;end;if not(rs<0)then else return H(ns,-rs);end;return(ns*C[rs])%t;end;H=H or function(mz,Az)do if Az>=0X20 then return 0X0;end;end;if not(Az<0)then else return l(mz,-Az);end;local wz=(0);local Gz=(nil);while 400477117 do if wz==0X0000 then do Gz=(mz%t/C[Az]);end;wz=1;else return Gz-Gz%0x0001;end;end;end;NB=0x00006;local j,P,pr,Ur,X,ir,Gr,p,er,Sr,br=nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,(nil);do while NB~=11 do if NB<=0X4 then if not(NB<=1)then if not(NB<=0X2)then if NB==0X00003 then er=function()local un=(0X0);local mn=0;while true do local Uw=u(y,K,K);K=K+1;un=un+((Uw>0x7F and Uw-128 or Uw)*C[mn]);if not(Uw<128)then else return un;end;mn=mn+7;end;end;NB=0X8;else do p=gB;end;NB=3;end;else Ur=function()local XV,jV,UV,KV=nil,nil,nil,nil;local zV=0x02;do repeat if zV<=0 then return KV*16777216+UV*0X10000+jV*0x100+XV;else if zV==1 then do K=K+4;end;do zV=0X0;end;else XV,jV,UV,KV=u(y,K,K+3);zV=0x1;end;end;until(false);end;end;NB=1;end;else if NB==0 then br={};NB=11;else do X=function(op,Yp,Zp)local lp=(op/C[Yp])%C[Zp];do lp=lp-lp%0X00001;end;return lp;end;end;NB=0x00a;end;end;else if not(NB<=0X007)then do if NB<=0x08 then Sr=P();NB=0X000;else if NB~=0X9 then ir=function()local ew,sw=Ur(),Ur();if sw==0X0 then return ew;elseif not(sw>=w)then else sw=sw-t;end;do return sw*t+ew;end;end;NB=7;else P=function()local vN=(u(y,K,K));local cN=1;while(true)do if cN~=0 then K=K+mr;do cN=0;end;else return vN;end;end;end;NB=0X00005;end;end;end;else if not(NB<=0x5)then if NB~=0X6 then do Gr=function()local NO,pO,vO,iO,SO,MO=0X00001,nil,nil,nil,nil,nil;while NO<=0X0005 do do if NO<=0X00002 then do if NO<=0 then if pO==0 and vO==0 then do return 0.0;end;end;NO=0X2;else if NO~=1 then SO=(-1)^X(vO,0X001f,mr);NO=0x00004;else pO=Ur();NO=3;end;end;end;else do if NO<=3 then do vO=Ur();end;NO=5;else do if NO==4 then MO=X(vO,JB,0Xb);NO=6;else do iO=1;end;NO=0;end;end;end;end;end;end;end;local BO=(X(vO,0X0,0x000014)*t+pO);do for kZ=0,1 do if kZ==0X0 then if MO==0X0 then if BO~=0X0 then local Up=(0X0);while(true)do if Up~=0x00000 then do iO=0;end;break;else MO=0X1;Up=0X0001;end;end;else return SO*0;end;elseif MO==0X7fF then do if BO~=0X0 then return SO*(1/0);else return SO*(0x0/Br);end;end;end;else return SO*(0X2^(MO-1023))*(BO/q+iO);end;end;end;end;end;NB=4;else j={[Qr]=8,[0X6]=0x3,[0x4]=0X1,[yr]=7,[0x5]=0X6,[3]=1,[0X03]=1,[0x7]=0,[2]=7};NB=0X9;end;else pr=function(...)return(...)();end;NB=2;end;end;end;end;end;NB=0X00003;local Jr,M,gr,B=nil,nil,nil,nil;repeat if not(NB<=1)then if NB==2 then B=ZB;do break;end;else Jr=function(gD)local cD=(2);local FD,UD=nil,nil;do while(true)do if not(cD<=1)then if cD<=2 then FD=Ur();do cD=0X0001;end;else if cD==0X03 then do return UD;end;else for UT=1,FD,7997 do local zT=0X3;local iT,TT=nil,(nil);do while zT<0X5 do if zT<=0X00001 then do if zT~=0 then if iT>FD then iT=FD;end;zT=0X00;else do TT={u(y,K+UT-0X1,K+iT-0X001)};end;zT=4;end;end;else do if zT<=0X2 then UD=UD..T(a(TT));zT=5;else if zT==0X0003 then iT=UT+0x1F3d-1;zT=1;else for cv=1,#TT do local vv=0;repeat do if vv==0X0 then(TT)[cv]=D(TT[cv],Sr);vv=0X00001;else Sr=(gD*Sr+0X55)%0X0100;vv=2;end;end;until vv>1;end;zT=0X2;end;end;end;end;end;end;end;cD=0x0;end;end;else if cD==0X00 then K=K+FD;cD=0x3;else UD=bB;cD=0x4;end;end;end;end;end;NB=0;end;else if NB==0 then M=vB;NB=0X1;else gr=function(...)return R("#",...),{...};end;NB=0X2;end;end;until false;local Zr={[0x0001]=br};do NB=0;end;local vr,Rr=nil,nil;while NB<=1 do if NB~=0X00000 then Rr=function()local tj=er();if not(tj>=q)then else return tj-O;end;return tj;end;NB=0X2;else vr=1;NB=1;end;end;local Nr=(ur);local Tr,cr=ur,ur;NB=0X00001;local Mr,Wr,dr=nil,nil,(nil);repeat if NB<=0X1 then if NB~=0x0 then function Mr(BS,OS,tS)local NS=BS[6];local TS=(BS[0X7]);local PS=BS[9];local aS=(BS[0X008]);local sS=(BS[0x5]);local pS=(BS[4]);local VS,RS=BS[0x2],BS[0X3];local dS=p({},{__mode="v"});local JS=nil;JS=function(...)local UW=(0X1);local eW={};local VW={[1]=BS,[0X02]=eW};local gW=(L and L()or _ENV);local uW,kW=gr(...);uW=uW-1;local bW,aW=(gW==Q and OS or gW),0X0;for EK=0X0,uW do if not(RS>EK)then break;else do eW[EK]=kW[EK+1];end;end;end;if not sS then kW=nil;elseif pS then(eW)[RS]={n=uW>=RS and uW-RS+1 or 0X000,a(kW,RS+1,uW+0X00001)};end;if bW==gW then else if not(B)then _ENV=bW;else B(JS,bW);end;end;local dW,sW,cW,OW=J(function()while true do local wB=(aS[UW]);local VB=wB[0x03];UW=UW+0X001;if VB<59 then if VB>=29 then if VB>=44 then do if not(VB>=0x33)then if not(VB>=47)then do if VB<45 then(eW[wB[0X2]])[wB[0x6]]=wB[0X00001];else if VB~=0X2E then eW[wB[0X02]]=bW[wB[0X6]];else(eW)[wB[2]]=true;end;end;end;else do if not(VB<49)then if VB~=0x32 then do if eW[wB[5]]~=wB[0X1]then else do UW=wB[2];end;end;end;else local wt=(wB[0x2]);local mt=o(function(...)F();for dA in...do F(true,dA);end;end);mt(eW[wt],eW[wt+1],eW[wt+2]);aW=wt;eW[wt]=mt;UW=wB[0X005];end;else do if VB~=0X30 then(eW)[wB[2]]=wB[6]*eW[wB[4]];else if not(not(eW[wB[0x5]]<=wB[0x1]))then else UW=wB[0X00002];end;end;end;end;end;end;else if not(VB>=0X0037)then if not(VB<53)then if VB~=0X36 then local f0=wB[2];local C0=eW[f0];local u0=(wB[4]-1)*0X32;for fe=1,aW-f0 do(C0)[u0+fe]=eW[f0+fe];end;else(eW)[wB[0x02]]={a({},1,wB[0X5])};end;else do if VB==0X034 then local Sx=(eW[wB[0X5]]/eW[wB[0X4]]);do eW[wB[0x2]]=Sx-Sx%0x1;end;else local oY=wB[0x2];local bY=(o(function(...)(F)();for tD,XD in...do(F)(true,tD,XD);end;end));bY(eW[oY],eW[oY+0X00001],eW[oY+2]);aW=oY;eW[oY]=bY;UW=wB[0x0005];end;end;end;else if VB>=57 then if VB==58 then eW[wB[2]]=wB[6]<eW[wB[4]];else(eW)[wB[0x2]]=wB[6]<wB[0X1];end;else do if VB~=0X38 then eW[wB[2]]=eW[wB[5]]/wB[1];else do if wB[4]==166 then do UW=UW-0X0001;end;aS[UW]={[0X03]=101,[0X005]=(wB[5]-0X0eD),[0X002]=(wB[2]-0xed)};else repeat local Zd,Ld=dS,(eW);local dd=({});for n6,e6 in E,Zd do for gE,JE in E,e6 do if JE[1]==Ld and JE[2]>=0 then local dH=JE[2];do if not dd[dH]then dd[dH]={Ld[dH]};end;end;JE[0X001]=dd[dH];JE[0X2]=1;end;end;end;until true;local xt=(wB[2]);return false,xt,xt;end;end;end;end;end;end;end;end;else if not(VB>=36)then if VB>=0X0020 then if not(VB<34)then do if VB~=35 then(VW)[wB[0X5]]=eW[wB[0X002]];else do eW[wB[2]]=wB[6]~=wB[1];end;end;end;else if VB~=33 then eW[wB[0X2]]=eW[wB[5]]-wB[0x1];else(eW)[wB[2]]=wB[6]-eW[wB[0X4]];end;end;else if VB>=0X1E then if VB==0X01F then do eW[wB[2]]=eW[wB[0X00005]]<=eW[wB[4]];end;else eW[wB[0x0002]]=eW[wB[0x05]]~=eW[wB[0X4]];end;else if not(wB[0X006]<eW[wB[4]])then UW=wB[2];end;end;end;else if VB<0X00028 then if not(VB<0X0026)then if VB==39 then if not(eW[wB[0x5]]<=eW[wB[0X4]])then UW=wB[0X2];end;else local YJ=wB[0x2];(eW[YJ])(a(eW,YJ+1,aW));do aW=YJ-0x1;end;end;else if VB~=0x25 then(eW)[wB[2]]=eW[wB[0X0005]]<wB[0X001];else eW[wB[2]]=eW[wB[5]]>=wB[0x1];end;end;else if not(VB>=42)then do if VB~=0X29 then local s9=wB[2];do aW=s9+wB[0X5]-1;end;(eW)[s9]=eW[s9](a(eW,s9+0X1,aW));aW=s9;else if eW[wB[5]]~=eW[wB[4]]then else UW=wB[2];end;end;end;else do if VB~=43 then if wB[0X4]==238 then UW=UW-0x1;(aS)[UW]={[0X0002]=(wB[0X0002]-0X49),[5]=(wB[5]-0X000049),[3]=17};elseif wB[0X004]~=0X00f3 then(eW)[wB[0X2]]=not eW[wB[5]];else do UW=UW-0X001;end;aS[UW]={[5]=(wB[5]-192),[2]=(wB[2]-192),[3]=0X62};end;else do(eW[wB[2]])[eW[wB[5]]]=eW[wB[0X004]];end;end;end;end;end;end;end;else do if not(VB<14)then do if VB<21 then if VB<17 then if VB>=15 then if VB~=16 then eW[wB[2]]=eW[wB[0X5]]%eW[wB[0X4]];else local fL,OL=VS[wB[5]],(nil);local QL=fL[0X1];local mL=(#QL);do if not(mL>0)then else OL={};for Kz=1,mL do local Hz=(QL[Kz]);if Hz[0X1]~=0X0 then OL[Kz-1]=tS[Hz[2]];else OL[Kz-0X1]={eW,Hz[0X2]};end;end;(W)(dS,OL);end;end;(eW)[wB[0X02]]=Mr(fL,bW,OL);end;else local JG=wB[2];local XG,gG=eW[JG]();if XG then for Wv=1,wB[4]do(eW)[JG+Wv]=gG[Wv];end;UW=wB[5];end;end;else if VB>=0x13 then if VB==20 then eW[wB[2]]=eW[wB[0X5]][eW[wB[0X004]]];else eW[wB[2]]=VW[wB[5]];end;else if VB~=18 then if wB[0X4]==0X5E then UW=UW-0X001;(aS)[UW]={[0X2]=(wB[0X2]-0X0043),[3]=0X47,[0X5]=(wB[5]-0X0043)};else local Ji,si=wB[2],(uW-RS);do if not(si<0X0)then else do si=-0X1;end;end;end;for tI=Ji,Ji+si do do eW[tI]=kW[RS+(tI-Ji)+0X1];end;end;aW=Ji+si;end;else local Gq=wB[0X2];local Mq=(wB[0X4]-1)*0x0032;local Jq=eW[Gq];for zu=0x1,wB[5]do(Jq)[Mq+zu]=eW[Gq+zu];end;end;end;end;else do if VB>=0X19 then if not(VB<27)then if VB~=28 then local Bb,xb=wB[0X002],wB[5];do if xb==0 then else do aW=Bb+xb-1;end;end;end;local Wb,ub,hb=wB[0X4],nil,(nil);do if xb==1 then ub,hb=gr(eW[Bb]());else do ub,hb=gr(eW[Bb](a(eW,Bb+1,aW)));end;end;end;if Wb==1 then do aW=Bb-0X0001;end;else do if Wb~=0 then ub=Bb+Wb-2;aW=ub+0X00001;else ub=ub+Bb-0x1;aW=ub;end;end;local Qq=(0);for CF=Bb,ub do do Qq=Qq+0x01;end;eW[CF]=hb[Qq];end;end;else do(eW)[wB[2]]=eW[wB[5]]<=wB[0X1];end;end;else do if VB==0X00001A then if not(eW[wB[0X00005]]<eW[wB[0x004]])then UW=wB[0X00002];end;else do(eW)[wB[0X00002]]=eW[wB[5]]+eW[wB[0X4]];end;end;end;end;else if not(VB>=0x17)then if VB==22 then(eW)[wB[2]]=wB[6];else(eW)[wB[0x2]]=wB[0X6]^eW[wB[4]];end;else if VB~=24 then local Gi=(tS[wB[5]]);eW[wB[0X02]]=Gi[1][Gi[2]];else if eW[wB[0X5]]==wB[0x1]then else do UW=wB[2];end;end;end;end;end;end;end;end;else if VB>=0X7 then do if VB>=10 then if not(VB>=0Xc)then do if VB==11 then local KT=(wB[2]);local cT=(wB[0X0005]);aW=KT+cT-1;repeat local jk,yk=dS,eW;local Dk=({});do for cb,ib in E,jk do for S_,e_ in E,ib do if not(e_[0X1]==yk and e_[0X2]>=0)then else local ki=e_[0X2];if not(not Dk[ki])then else do(Dk)[ki]={yk[ki]};end;end;e_[0X1]=Dk[ki];e_[0X0002]=1;end;end;end;end;until true;return true,KT,cT;else eW[wB[0X2]]=eW[wB[0X5]]^eW[wB[4]];end;end;else if VB==13 then local Mm=(wB[2]);local Km=(eW[wB[0X5]]);do eW[Mm+0X001]=Km;end;(eW)[Mm]=Km[wB[1]];else local SL=(wB[0x2]);aW=SL+wB[0X5]-0X1;eW[SL](a(eW,SL+1,aW));aW=SL-1;end;end;else do if VB<0X8 then do(bW)[wB[6]]=eW[wB[2]];end;else if VB==9 then do(eW)[wB[0X2]]=wB[0X00006]<=eW[wB[0X4]];end;else local XS=(wB[5]);do(eW)[wB[2]]=eW[XS]..eW[XS+0x1];end;end;end;end;end;end;else if not(VB>=0X3)then if not(VB<0X00001)then if VB~=2 then local TJ=(tS[wB[0x5]]);do(TJ[0X00001])[TJ[2]]=eW[wB[2]];end;else do(eW)[wB[2]]=eW[wB[0x5]]*eW[wB[0X004]];end;end;else local Jj=(wB[2]);local Vj,kj,Kj=eW[Jj]();do if Vj then do eW[Jj+0X1]=kj;end;eW[Jj+0x002]=Kj;UW=wB[0x5];end;end;end;else if not(VB<5)then if VB==6 then eW[wB[0X02]]=r(eW[wB[5]],eW[wB[0X4]]);else(eW)[wB[0x2]]=eW[wB[5]]%wB[1];end;else if VB~=4 then do if wB[0x00004]~=188 then for Aq=wB[2],wB[5]do(eW)[Aq]=nil;end;else UW=UW-1;(aS)[UW]={[2]=(wB[2]-249),[5]=(wB[5]-0X000f9),[0x3]=104};end;end;else local ru=wB[2];local Qu=o(function(...)(F)();for Q0,A0,t0,l0,c0,O0,L0,E0,d0,T0 in...do(F)(true,{Q0,A0,t0,l0,c0,O0,L0,E0,d0,T0});end;end);Qu(eW[ru],eW[ru+0X00001],eW[ru+2]);aW=ru;do(eW)[ru]=Qu;end;UW=wB[0X5];end;end;end;end;end;end;end;else if VB>=0X00058 then do if not(VB>=103)then if not(VB<0x5F)then do if not(VB<99)then do if VB>=0X65 then if VB~=0X00066 then do repeat local Kj,Dj=dS,(eW);local Jj=({});do for B_,G_ in E,Kj do do for bG,UG in E,G_ do do if UG[1]==Dj and UG[0X2]>=0X00000 then local bF=(UG[2]);if not(not Jj[bF])then else(Jj)[bF]={Dj[bF]};end;(UG)[1]=Jj[bF];(UG)[2]=0X01;end;end;end;end;end;end;until true;end;do return;end;else if not eW[wB[2]]then UW=wB[0X5];end;end;else if VB~=0X64 then if not(not(wB[0X006]<=eW[wB[0X4]]))then else UW=wB[2];end;else do(eW)[wB[0X2]]=wB[6]+wB[1];end;end;end;end;else if VB<97 then if VB==96 then eW[wB[0x2]]=V(eW[wB[0x5]],eW[wB[4]]);else local Sf=VS[wB[5]];local Lf=(nil);local df=(Sf[0X1]);local zf=#df;if not(zf>0)then else Lf={};for Nc=0X01,zf do local pc=(df[Nc]);if pc[1]==0X000 then do(Lf)[Nc-0x1]={eW,pc[2]};end;else do(Lf)[Nc-0X001]=tS[pc[0X00002]];end;end;end;(W)(dS,Lf);end;eW[wB[0x2]]=i[wB[4]](Lf);end;else if VB==0X00062 then repeat local aQ,JQ=dS,(eW);local pQ=({});for CQ,EQ in E,aQ do for Rl,ml in E,EQ do do if not(ml[1]==JQ and ml[0X2]>=0x00)then else local d8=(ml[2]);do if not(not pQ[d8])then else pQ[d8]={JQ[d8]};end;end;do(ml)[1]=pQ[d8];end;ml[0X002]=1;end;end;end;end;until true;local mm=(wB[0X0002]);do return false,mm,mm+wB[5]-0x02;end;else local dk=wB[0X5];local yk=(eW[dk]);do for WH=dk+1,wB[0X4]do yk=yk..eW[WH];end;end;do(eW)[wB[2]]=yk;end;end;end;end;end;else if VB>=91 then if VB<93 then do if VB==0X5C then eW[wB[2]]=eW[wB[0X005]]>wB[1];else eW[wB[0X2]]=wB[6]<=wB[1];end;end;else if VB~=0X05e then do(eW)[wB[0X02]]=eW[wB[0X5]]*wB[0X1];end;else eW[wB[2]]=wB[0X6]>wB[0X1];end;end;else if not(VB>=0X59)then eW[wB[2]]=Zr[wB[0x00005]];else do if VB==90 then eW[wB[0X2]]=D(eW[wB[0X5]],eW[wB[4]]);else eW[wB[2]]=l(eW[wB[0X5]],eW[wB[0X4]]);end;end;end;end;end;else if not(VB<110)then do if VB<0X72 then if not(VB>=0X00070)then if VB~=111 then local li=wB[2];local Ai,zi=eW[li]();do if not(Ai)then else UW=wB[0X5];(eW)[li+3]=zi;end;end;else local sB=wB[2];for vw=sB,sB+(wB[0x5]-0x1)do eW[vw]=kW[RS+(vw-sB)+1];end;end;else if VB~=0X71 then local UE=wB[0X2];do eW[UE]=eW[UE](a(eW,UE+0X1,aW));end;do aW=UE;end;else(eW)[wB[2]]=eW[wB[5]][wB[0X1]];end;end;else if not(VB>=0X0074)then if VB~=0X000073 then do Zr[wB[5]]=eW[wB[2]];end;else if not(eW[wB[5]]<eW[wB[4]])then else do UW=wB[0X0002];end;end;end;else do if VB~=117 then eW[wB[0X2]]=eW[wB[0X05]]+wB[0X1];else local aP=(wB[0X2]);eW[aP]=eW[aP](eW[aP+1]);aW=aP;end;end;end;end;end;else if VB<0X0006a then if VB<104 then local En=(wB[2]);local Bn,bn=eW[En]();do if not(Bn)then else(eW)[En+1]=bn;do UW=wB[0X0005];end;end;end;else if VB==0X69 then repeat local tA,NA=dS,eW;local DA=({});for MG,PG in E,tA do for iw,Ww in E,PG do if not(Ww[1]==NA and Ww[2]>=0)then else local cU=(Ww[2]);if not DA[cU]then DA[cU]={NA[cU]};end;Ww[1]=DA[cU];Ww[0X2]=0X1;end;end;end;until true;return true,wB[2],0X0;else repeat local TX,mX=dS,(eW);local VX=({});for Rz,Wz in E,TX do for aO,yO in E,Wz do if yO[1]==mX and yO[0X2]>=0X0 then local xw=yO[0X2];if not(not VX[xw])then else(VX)[xw]={mX[xw]};end;yO[1]=VX[xw];do(yO)[0X2]=1;end;end;end;end;until true;do return false,wB[2],aW;end;end;end;else do if not(VB>=0X6c)then if VB~=107 then UW=wB[5];else(eW)[wB[0X2]]=eW[wB[5]]==wB[0X1];end;else if VB==109 then do if wB[4]==11 then UW=UW-1;(aS)[UW]={[0X02]=(wB[2]-0X1B),[5]=(wB[5]-27),[3]=0X042};else do(eW)[wB[0x02]]=kW[RS+0x1];end;end;end;else do repeat local vq,Fq=dS,(eW);local cq={};for oZ,DZ in E,vq do for eh,yh in E,DZ do if not(yh[0X00001]==Fq and yh[2]>=0X00)then else local Nb=(yh[2]);if not(not cq[Nb])then else(cq)[Nb]={Fq[Nb]};end;yh[1]=cq[Nb];yh[0x2]=0X0001;end;end;end;until true;end;do return true,wB[2],0X1;end;end;end;end;end;end;end;end;else if not(VB<0X00049)then if not(VB>=0X50)then do if not(VB<0x00004C)then if not(VB>=0X4e)then if VB==77 then eW[wB[2]]=A(eW[wB[5]]);else do if eW[wB[0X5]]<=eW[wB[0X004]]then do UW=wB[0x2];end;end;end;end;else if VB==0X4f then do eW[wB[2]]=eW[wB[5]]>eW[wB[4]];end;else do eW[wB[2]]=eW[wB[0X5]]/eW[wB[0X4]];end;end;end;else if not(VB<0X4A)then do if VB==0X004b then(eW)[wB[0X2]]={};else eW[wB[0x2]]=eW[wB[0X5]]>=eW[wB[0X4]];end;end;else repeat local J9,V9,G9=dS,eW,(wB[0X0002]);local I9={};for Bn,Cn in E,J9 do for zI,NI in E,Cn do do if NI[0X01]==V9 and NI[0X2]>=G9 then local S7=(NI[2]);if not I9[S7]then do I9[S7]={V9[S7]};end;end;(NI)[1]=I9[S7];(NI)[0x0002]=1;end;end;end;end;until true;end;end;end;else if not(VB>=0X54)then if VB<0X52 then if VB~=0X51 then do aW=wB[2];end;do(eW)[aW]=eW[aW]();end;else local ii=wB[0X2];local Gi,Vi,Si=eW[ii],eW[ii+0X00001],eW[ii+2];(eW)[ii]=o(function()for U4=Gi,Vi,Si do F(true,U4);end;end);UW=wB[5];end;else do if VB~=83 then do eW[wB[0x2]][wB[6]]=eW[wB[0x0004]];end;else repeat local cG,bG=dS,(eW);local qG={};do for W_,h_ in E,cG do for Bn,Dn in E,h_ do do if not(Dn[0x1]==bG and Dn[2]>=0)then else local YD=(Dn[2]);if not qG[YD]then do qG[YD]={bG[YD]};end;end;(Dn)[0X1]=qG[YD];(Dn)[2]=1;end;end;end;end;end;until true;local BE=(wB[2]);aW=BE+1;return true,BE,2;end;end;end;else do if not(VB<86)then if VB~=87 then eW[wB[2]]=eW[wB[5]]<eW[wB[0X4]];else(eW)[wB[2]]=eW[wB[0X5]]==eW[wB[0X04]];end;else if VB~=85 then(eW)[wB[0X2]]=H(eW[wB[5]],eW[wB[0X04]]);else local Lq=(wB[2]);eW[Lq](eW[Lq+1]);do aW=Lq-1;end;end;end;end;end;end;else if not(VB>=0X000042)then if not(VB<62)then if VB<0X40 then if VB~=63 then(eW[wB[2]])[eW[wB[5]]]=wB[1];else aW=wB[0X0002];(eW[aW])();aW=aW-1;end;else if VB~=65 then if wB[0x4]==0X00019 then UW=UW-0x01;aS[UW]={[3]=0X47,[2]=(wB[0x002]-0xc8),[0x0005]=(wB[5]-0xc8)};elseif wB[4]==0xe2 then UW=UW-1;aS[UW]={[0X5]=(wB[5]-0X59),[0x2]=(wB[2]-89),[0x3]=66};elseif wB[4]==0X00C4 then UW=UW-1;(aS)[UW]={[3]=67,[0X5]=(wB[0x0005]-148),[2]=(wB[2]-0X0094)};elseif wB[0X00004]==0xcd then UW=UW-1;do(aS)[UW]={[0x3]=0X00002A,[5]=(wB[5]-0X056),[2]=(wB[2]-0x56)};end;else(eW)[wB[0X2]]=#eW[wB[0X05]];end;else(eW)[wB[2]]=wB[0X6]-wB[1];end;end;else if VB<60 then do if wB[4]==105 then UW=UW-0X00001;aS[UW]={[0X0002]=(wB[2]-0x024),[0x5]=(wB[5]-0X000024),[3]=0X06d};elseif wB[4]~=152 then if not(eW[wB[0x2]])then else do UW=wB[5];end;end;else UW=UW-1;aS[UW]={[0x5]=(wB[0X5]-0XdA),[2]=(wB[0X002]-0XdA),[0X3]=0x3};end;end;else if VB==0X00003D then if not(not(eW[wB[5]]<wB[1]))then else UW=wB[0X2];end;else if eW[wB[0X5]]==eW[wB[0X0004]]then else do UW=wB[2];end;end;end;end;end;else if not(VB<0X45)then if VB<71 then do if VB==0X46 then do(eW)[wB[2]]=eW[wB[5]]~=wB[1];end;else local c7=wB[2];eW[c7](eW[c7+1],eW[c7+2]);aW=c7-1;end;end;else if VB==0X48 then local jN=wB[2];eW[jN]=eW[jN](eW[jN+1],eW[jN+0X0002]);aW=jN;else if wB[4]==0X0C1 then UW=UW-0X1;aS[UW]={[5]=(wB[0X05]-0X37),[3]=0X62,[2]=(wB[2]-0x37)};elseif wB[4]==223 then do UW=UW-1;end;aS[UW]={[0X002]=(wB[2]-0X7e),[0X5]=(wB[0X5]-126),[3]=101};else eW[wB[0X2]]=nil;end;end;end;else if not(VB<67)then if VB==68 then do eW[wB[2]]=eW[wB[0X5]]-eW[wB[0x004]];end;else(eW)[wB[2]]=-eW[wB[5]];end;else if wB[0X4]==71 then UW=UW-0x1;aS[UW]={[0x3]=17,[0x5]=(wB[5]-66),[0X2]=(wB[2]-66)};elseif wB[4]~=32 then eW[wB[2]]=eW[wB[5]];else UW=UW-1;do aS[UW]={[3]=0X62,[5]=(wB[5]-0X9B),[0x002]=(wB[2]-155)};end;end;end;end;end;end;end;end;end;end);if dW then if sW then if OW~=0x001 then return eW[cW](a(eW,cW+1,aW));else return eW[cW]();end;elseif cW then return a(eW,cW,OW);end;else if g(sW)=='str\105\110\103'then if not(M(sW,"attempt to yield across metamethod/C%-call boundary"))then else return F();end;do if M(sW,"^.-:%d+: ")then v("Luraph Script:"..(NS[UW-0X1]or"(\105nt\101\114\110\097\108\041")..':\032'..b(sW),0X0);else v(sW,0);end;end;else v(sW,0X000);end;end;end;if B then B(JS,OS);end;return JS;end;NB=2;else dr=Wr();NB=3;end;elseif NB~=0x0002 then dr=Mr(dr,Q,nil)(Wr,U,k,pr,Gr,P,Ur,G);break;else function Wr()local I8,d8,Q8=nil,nil,nil;local p8=3;while p8<0X004 do if not(p8<=1)then if p8==0X2 then d8={nil,{},nil,Ar,Ar,{},nil,{},nil};p8=0;else I8={};p8=2;end;else do if p8~=0X000 then do(d8)[0X3]=er();end;p8=0X4;else Q8=0X1;do p8=1;end;end;end;end;end;local T8=(d8[0x2]);local k8,j8,A8=nil,nil,nil;for O3=0,0X09 do if O3<=0X4 then if not(O3<=0X1)then if not(O3<=2)then if O3~=3 then d8[10]=Ur();else do(d8)[0X7]=er();end;end;else do d8[0X13]=P();end;end;else if O3==0 then k8=Ur()-0X14ad7;else for Fm=0x00,k8-mr do T8[Fm]=Wr();end;end;end;else if not(O3<=0x00006)then do if O3<=7 then d8[0x5]=X(j8,0x1,0x01)~=0;else if O3~=8 then A8={};else d8[4]=X(j8,2,1)~=0;end;end;end;else if O3~=5 then j8=P();else d8[0X12]=P();end;end;end;end;p8=0;local a8=nil;do while p8<=0x00001 do if p8==0X00 then d8[10]=P();p8=0X00001;else a8=Ur()-0X3D4A;p8=0X00002;end;end;end;local Y8=(d8[0X008]);for d2=0X0,1 do do if d2==0 then for BN=mr,a8 do local VN,gN,nN,aN=Rr(),Rr(),Rr(),(Rr());local fN,mN,NN=aN%0x4,VN%0x4,(nN%0x4);Y8[BN]={[2]=(nN-NN)/0x4,[0X4]=(aN-fN)/0x4,[yr]=NN,[3]=gN,[0x1]=fN,[5]=(VN-mN)/Kr,[6]=mN};end;else(d8)[wr]=Ur();end;end;end;local O8=d8[6];p8=2;local l8,V8,o8,B8=nil,nil,nil,(nil);repeat if not(p8<=0X00003)then if p8<=0X00005 then do if p8==0x4 then d8[0X01]=A8;p8=0X5;else for Ch=1,er()do A8[Ch]={P(),er()};end;p8=6;end;end;else if p8~=6 then do o8=Ur()-0X13a6;end;p8=0X0;else do d8[11]=P();end;do p8=0X7;end;end;end;else if p8<=1 then do if p8~=0 then V8={};p8=4;else B8=P();p8=8;end;end;else if p8==0X2 then l8=Ur();p8=0X00003;else do for pP=0X1,l8 do local ZP=(Ur());local eP=(Ur());local mP=(Ur());for XN=ZP,eP do do(O8)[XN]=mP;end;end;end;end;p8=0x1;end;end;end;until p8>7;local M8=(nil);do for gO=0x0,3 do do if not(gO<=0X001)then if gO~=2 then d8[0XA]=P();else do(d8)[0xa]=Ur();end;end;else do if gO==0 then do M8=P()~=0;end;else for RS=1,o8 do local zS,lS,NS,XS=0x1,nil,nil,nil;do while zS~=6 do if not(zS<=2)then do if zS<=3 then V8[Q8]=XS;do zS=6;end;else if zS==0x4 then NS=P();do zS=0X0000;end;else(I8)[RS-1]=Q8;do zS=3;end;end;end;end;else if zS<=0X0 then if NS==125 then lS=ir();elseif NS==102 then lS=Gr()+Ur();elseif NS==0X012 then lS=ir();elseif NS==0X95 then lS=Z(Jr(B8),Gr()+Ur());elseif NS==uB then lS=Gr();elseif NS==Qr then lS=Z(Jr(B8),P());elseif NS==0x002c then lS=Z(Jr(B8),0X0002);elseif NS==0xFf then do lS=Nr(0,Gr());end;elseif NS==162 then lS=Z(Jr(B8),P());elseif NS==TB then lS=ir();elseif NS==193 then lS=P()==1;elseif NS==133 then lS=Ur()+Tr(Ur())*t;elseif NS==cB then do lS=Z(Jr(B8),Gr()+Ur());end;elseif NS~=0X020 then else lS=Ur()+cr(Ur())*t;end;do zS=2;end;else if zS~=0X0001 then XS={lS,{}};do zS=5;end;else do lS=nil;end;do zS=4;end;end;end;end;end;end;for Dq=0X0,1 do if Dq==0 then do Q8=Q8+1;end;else do if M8 then local u0=(0);do while u0~=2 do if u0~=0 then vr=vr+1;u0=0x2;else(br)[vr]=XS;u0=0X1;end;end;end;end;end;end;end;end;end;end;end;end;end;end;p8=0x01;while p8<=1 do if p8~=0 then d8[0X0000C]=Ur();p8=0;else do(d8)[13]=P();end;do p8=0X2;end;end;end;do(d8)[9]=er();end;for Px=1,a8 do local ax=(d8[0X008][Px]);do for Ax,ix in E,h do local xx,mx,qx=1,nil,(nil);while xx<3 do if xx<=0X00 then qx=ax[mx];do xx=2;end;else if xx==0X0001 then mx=j[ix];do xx=0X0;end;else if qx==0x0 then local tm,fm=nil,(nil);local Fm=(2);do while Fm~=3 do if Fm<=0 then fm=V8[tm];Fm=0X0001;else do if Fm~=1 then tm=I8[ax[ix]];Fm=0;else if fm then local JM=(0X00001);local QM=nil;while JM<=2 do do if JM<=0 then QM=fm[0X02];JM=0X2;else if JM==0X1 then(ax)[mx]=fm[1];JM=0x0;else do QM[#QM+0X1]={ax,mx};end;do JM=0X3;end;end;end;end;end;end;Fm=0x003;end;end;end;end;end;elseif qx~=0X3 then else ax[ix]=Px+ax[ix]+1;end;xx=3;end;end;end;end;end;end;return d8;end;NB=0X00;end;until(false);return Mr(dr,Q,Ar);end)(0x0000B,2,0x5,155,unpack,14,0X9,0X00C,20,"lshift",assert,0xa,table.unpack,coroutine.wrap,13,0x010000000000000,62,string.sub,setfenv,0x06,coroutine,0X0001,string,0X003,8,0X800000,type,setmetatable,"",0X000C6,0,tonumber,string.match,bit,tostring,0X0020,268435456,7,'\098x\111r',4,getfenv,_ENV,67108864,'\114\115\104ift',nil,'\098\110o\116',function(...)(...)[...]=nil;end,{},{0X00510A,0XC18eBb34,2103285456,2015370915,0x00003259d89b,0XFF3dBE78,1947654257,0X0045B27a79,538316313})(...);]=],WW,TA;if n==(0x001) then return else IH={0x1,lZ(WW),0x3,1,2} assa=('local KJ=cl[0x0];do(DI)[0]=KJ[0X1][KJ[2]];end;lI=lI+1;lI=lI+1;x_=Wl[lI];lI=lI+0X1;DI[0]=DI[0X000][x_[0x6]];do x_=Wl[lI];end;do lI=lI+1;end;(DI)[0]=DI[0X0][x_[6]];lI=lI+1;lI=lI+1;do x_=Wl[lI];end;lI=lI+0X1;(DI)[0X0000]=DI[0X0][x_[0X6]];lI=lI+0X1;lI=lI+1;lI=lI+0X1;KJ=cl[1];(DI)[1]=KJ[1][KJ[2]];x_=Wl[lI];lI=lI+0X1;DI[0X1]=DI[1][x_[0X6]];lI=lI+1;lI=lI+0x01;x_=Wl[lI];lI=lI+0X00001;(DI)[0X1]=DI[1][x_[6]];do x_=Wl[lI];end;lI=lI+1;(DI)[0x1]=DI[1][x_[6]];do lI=lI+0X1;end;lI=lI+1;lI=lI+0X01;DI[0]=DI[0X0]-DI[1];x_=Wl[lI];lI=lI+1;(DI)[0x0]=DI[0X00][x_[0X0006]];lI=lI+1;do lI=lI+1;end;x_=Wl[lI];do lI=lI+0x1;end;do if not(not(DI[0x00000]<=x_[0X006]))then else do lI=x_[3];end;end;end;end;end;else if not(t_>=3)then local km,ym=sl[x_[0x2]],nil;local em=km[0X9];local xm=#em;if not(xm>0x000)then else ym={};for CL=0X1,xm do local bL=em[CL];if bL[1]~=0X0 then ym[CL-0X0001]=cl[bL[2]]');local cSe=wu(IH[0x5-3+0x00]);TA=b;ke=b;pM=b;oU=b;sQ=B;cSe();WW=(____);wn=(___);wu=(__);dsi=('local KJ=cl[0x0];do(DI)[0]=KJ[0X1][KJ[2]];end;lI=lI+1;lI=lI+1;x_=Wl[lI];lI=lI+0X1;DI[0]=DI[0X000][x_[0x6]];do x_=Wl[lI];end;do lI=lI+1;end;(DI)[0]=DI[0X0][x_[6]];lI=lI+1;lI=lI+1;do x_=Wl[lI];end;lI=lI+0X1;(DI)[0X0000]=DI[0X0][x_[0X6]];lI=lI+0X1;lI=lI+1;lI=lI+0X1;KJ=cl[1];(DI)[1]=KJ[1][KJ[2]];x_=Wl[lI];lI=lI+0X1;DI[0X1]=DI[1][x_[0X6]];lI=lI+1;lI=lI+0x01;x_=Wl[lI];lI=lI+0X00001;(DI)[0X1]=DI[1][x_[6]];do x_=Wl[lI];end;lI=lI+1;(DI)[0x1]=DI[1][x_[6]];do lI=lI+0X1;end;lI=lI+1;lI=lI+0X01;DI[0]=DI[0X0]-DI[1];x_=Wl[lI];lI=lI+1;(DI)[0x0]=DI[0X00][x_[0X0006]];lI=lI+1;do lI=lI+1;end;x_=Wl[lI];do lI=lI+0x1;end;do if not(not(DI[0x00000]<=x_[0X006]))then else do lI=x_[3];end;end;end;end;end;else if not(t_>=3)then local km,ym=sl[x_[0x2]],nil;local em=km[0X9];local xm=#em;if not(xm>0x000)then else ym={};for CL=0X1,xm do local bL=em[CL];if bL[1]~=0X0 then ym[CL-0X0001]=cl[bL[2]]');wn,WW,TA=(___),(____);end;dsi=('local KJ=cl[0x0];do(DI)[0]=KJ[0X1][KJ[2]];end;lI=lI+1;lI=lI+1;x_=Wl[lI];lI=lI+0X1;DI[0]=DI[0X000][x_[0x6]];do x_=Wl[lI];end;do lI=lI+1;end;(DI)[0]=DI[0X0][x_[6]];lI=lI+1;lI=lI+1;do x_=Wl[lI];end;lI=lI+0X1;(DI)[0X0000]=DI[0X0][x_[0X6]];lI=lI+0X1;lI=lI+1;lI=lI+0X1;KJ=cl[1];(DI)[1]=KJ[1][KJ[2]];x_=Wl[lI];lI=lI+0X1;DI[0X1]=DI[1][x_[0X6]];lI=lI+1;lI=lI+0x01;x_=Wl[lI];lI=lI+0X00001;(DI)[0X1]=DI[1][x_[6]];do x_=Wl[lI];end;lI=lI+1;(DI)[0x1]=DI[1][x_[6]];do lI=lI+0X1;end;lI=lI+1;lI=lI+0X01;DI[0]=DI[0X0]-DI[1];x_=Wl[lI];lI=lI+1;(DI)[0x0]=DI[0X00][x_[0X0006]];lI=lI+1;do lI=lI+1;end;x_=Wl[lI];do lI=lI+0x1;end;do if not(not(DI[0x00000]<=x_[0X006]))then else do lI=x_[3];end;end;end;end;end;else if not(t_>=3)then local km,ym=sl[x_[0x2]],nil;local em=km[0X9];local xm=#em;if not(xm>0x000)then else ym={};for CL=0X1,xm do local bL=em[CL];if bL[1]~=0X0 then ym[CL-0X0001]=cl[bL[2]]');end)()	
